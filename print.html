<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust-LINFO2315 (adapted from Comprehensive Rust ü¶Ä)</title>
        <meta name="robots" content="noindex" />
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
                data-autoload-cookie-consent-bar="true"></script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZN78TEJMRW');
        </script>

        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="svgbob.css">
        <link rel="stylesheet" href="speaker-notes.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="welcome.html">Welcome to Comprehensive Rust ü¶Ä</a></li><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.</strong> Course Structure</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">2.</strong> Keyboard Shortcuts</a></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">3.</strong> Using Cargo</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">3.1.</strong> Rust Ecosystem</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">3.2.</strong> Code Samples</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">3.3.</strong> Running Cargo Locally</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 1</li><li class="spacer"></li><li class="chapter-item "><a href="course-1.html"><strong aria-hidden="true">4.</strong> Welcome</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="course-1/what-is-rust.html"><strong aria-hidden="true">4.1.</strong> What is Rust?</a></li></ol></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">5.</strong> Hello World!</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/small-example.html"><strong aria-hidden="true">5.1.</strong> Small Example</a></li></ol></li><li class="chapter-item "><a href="why-rust.html"><strong aria-hidden="true">6.</strong> Why Rust?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="why-rust/compile-time.html"><strong aria-hidden="true">6.1.</strong> Compile Time Guarantees</a></li><li class="chapter-item "><a href="why-rust/runtime.html"><strong aria-hidden="true">6.2.</strong> Runtime Guarantees</a></li><li class="chapter-item "><a href="why-rust/modern.html"><strong aria-hidden="true">6.3.</strong> Modern Features</a></li></ol></li><li class="chapter-item "><a href="basic-syntax.html"><strong aria-hidden="true">7.</strong> Basic Syntax</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/if-expressions.html"><strong aria-hidden="true">7.1.</strong> If expressions</a></li><li class="chapter-item "><a href="basic-syntax/scalar-types.html"><strong aria-hidden="true">7.2.</strong> Scalar Types</a></li><li class="chapter-item "><a href="basic-syntax/compound-types.html"><strong aria-hidden="true">7.3.</strong> Compound Types</a></li><li class="chapter-item "><a href="basic-syntax/references.html"><strong aria-hidden="true">7.4.</strong> References</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/references-dangling.html"><strong aria-hidden="true">7.4.1.</strong> Dangling References</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/slices.html"><strong aria-hidden="true">7.5.</strong> Slices</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/string-slices.html"><strong aria-hidden="true">7.5.1.</strong> String vs str</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/functions.html"><strong aria-hidden="true">7.6.</strong> Functions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/methods.html"><strong aria-hidden="true">7.6.1.</strong> Methods</a></li><li class="chapter-item "><a href="basic-syntax/functions-interlude.html"><strong aria-hidden="true">7.6.2.</strong> Overloading</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/course-1/morning.html"><strong aria-hidden="true">8.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-1/implicit-conversions.html"><strong aria-hidden="true">8.1.</strong> Implicit Conversions</a></li><li class="chapter-item "><a href="exercises/course-1/matrix-mult.html"><strong aria-hidden="true">8.2.</strong> Matrix multiplication</a></li><li class="chapter-item "><a href="exercises/course-1/for-loops.html"><strong aria-hidden="true">8.3.</strong> Arrays and for Loops</a></li><li class="chapter-item "><a href="exercises/course-1/palindrome.html"><strong aria-hidden="true">8.4.</strong> Palindrome</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 2</li><li class="spacer"></li><li class="chapter-item "><a href="course-2.html"><strong aria-hidden="true">9.</strong> Welcome</a></li><li class="chapter-item "><a href="basic-syntax/variables.html"><strong aria-hidden="true">10.</strong> Variables</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/type-inference.html"><strong aria-hidden="true">10.1.</strong> Type Inference</a></li><li class="chapter-item "><a href="basic-syntax/option.html"><strong aria-hidden="true">10.2.</strong> Option</a></li><li class="chapter-item "><a href="basic-syntax/static-and-const.html"><strong aria-hidden="true">10.3.</strong> static & const</a></li><li class="chapter-item "><a href="basic-syntax/scopes-shadowing.html"><strong aria-hidden="true">10.4.</strong> Scopes and Shadowing</a></li></ol></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">11.</strong> Memory Management</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/stack-vs-heap.html"><strong aria-hidden="true">11.1.</strong> Stack vs Heap</a></li><li class="chapter-item "><a href="memory-management/stack.html"><strong aria-hidden="true">11.2.</strong> Stack Memory</a></li><li class="chapter-item "><a href="memory-management/manual.html"><strong aria-hidden="true">11.3.</strong> Manual Memory Management</a></li><li class="chapter-item "><a href="memory-management/scope-based.html"><strong aria-hidden="true">11.4.</strong> Scope-Based Memory Management</a></li><li class="chapter-item "><a href="memory-management/garbage-collection.html"><strong aria-hidden="true">11.5.</strong> Garbage Collection</a></li><li class="chapter-item "><a href="memory-management/rust.html"><strong aria-hidden="true">11.6.</strong> Rust Memory Management</a></li><li class="chapter-item "><a href="memory-management/comparison.html"><strong aria-hidden="true">11.7.</strong> Comparison</a></li></ol></li><li class="chapter-item "><a href="ownership.html"><strong aria-hidden="true">12.</strong> Ownership</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/move-semantics.html"><strong aria-hidden="true">12.1.</strong> Move Semantics</a></li><li class="chapter-item "><a href="ownership/moved-strings-rust.html"><strong aria-hidden="true">12.2.</strong> Moved Strings in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/double-free-modern-cpp.html"><strong aria-hidden="true">12.2.1.</strong> Double Frees in Modern C++</a></li></ol></li><li class="chapter-item "><a href="ownership/moves-function-calls.html"><strong aria-hidden="true">12.3.</strong> Moves in Function Calls</a></li><li class="chapter-item "><a href="ownership/copy-clone.html"><strong aria-hidden="true">12.4.</strong> Copying and Cloning</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">12.5.</strong> Borrowing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/shared-unique-borrows.html"><strong aria-hidden="true">12.5.1.</strong> Shared and Unique Borrows</a></li></ol></li><li class="chapter-item "><a href="ownership/lifetimes.html"><strong aria-hidden="true">12.6.</strong> Lifetimes</a></li><li class="chapter-item "><a href="ownership/lifetimes-function-calls.html"><strong aria-hidden="true">12.7.</strong> Lifetimes in Function Calls</a></li><li class="chapter-item "><a href="ownership/lifetimes-data-structures.html"><strong aria-hidden="true">12.8.</strong> Lifetimes in Data Structures</a></li></ol></li><li class="chapter-item "><a href="exercises/course-2/afternoon.html"><strong aria-hidden="true">13.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-2/book-library.html"><strong aria-hidden="true">13.1.</strong> Designing a Library</a></li><li class="chapter-item "><a href="exercises/course-2/iterators-and-ownership.html"><strong aria-hidden="true">13.2.</strong> Iterators and Ownership</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 3</li><li class="spacer"></li><li class="chapter-item "><a href="course-3.html"><strong aria-hidden="true">14.</strong> Welcome</a></li><li class="chapter-item "><a href="structs.html"><strong aria-hidden="true">15.</strong> Structs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="structs/tuple-structs.html"><strong aria-hidden="true">15.1.</strong> Tuple Structs</a></li><li class="chapter-item "><a href="structs/field-shorthand.html"><strong aria-hidden="true">15.2.</strong> Field Shorthand Syntax</a></li></ol></li><li class="chapter-item "><a href="enums.html"><strong aria-hidden="true">16.</strong> Enums</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="enums/variant-payloads.html"><strong aria-hidden="true">16.1.</strong> Variant Payloads</a></li><li class="chapter-item "><a href="enums/sizes.html"><strong aria-hidden="true">16.2.</strong> Enum Sizes</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">17.</strong> Methods</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods/receiver.html"><strong aria-hidden="true">17.1.</strong> Method Receiver</a></li><li class="chapter-item "><a href="methods/example.html"><strong aria-hidden="true">17.2.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">18.</strong> Pattern Matching</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">18.1.</strong> Destructuring Enums</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">18.2.</strong> Destructuring Structs</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-arrays.html"><strong aria-hidden="true">18.3.</strong> Destructuring Arrays</a></li><li class="chapter-item "><a href="pattern-matching/match-guards.html"><strong aria-hidden="true">18.4.</strong> Match Guards</a></li></ol></li><li class="chapter-item "><a href="exercises/course-3/morning.html"><strong aria-hidden="true">19.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-3/health-statistics.html"><strong aria-hidden="true">19.1.</strong> Health Statistics</a></li><li class="chapter-item "><a href="exercises/course-3/points-polygons.html"><strong aria-hidden="true">19.2.</strong> Points and Polygons</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 4</li><li class="spacer"></li><li class="chapter-item "><a href="course-4.html"><strong aria-hidden="true">20.</strong> Welcome</a></li><li class="chapter-item "><a href="control-flow.html"><strong aria-hidden="true">21.</strong> Control Flow</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/if-let-expressions.html"><strong aria-hidden="true">21.1.</strong> if let expressions</a></li><li class="chapter-item "><a href="control-flow/while-expressions.html"><strong aria-hidden="true">21.2.</strong> while expressions</a></li><li class="chapter-item "><a href="control-flow/while-let-expressions.html"><strong aria-hidden="true">21.3.</strong> while let expressions</a></li><li class="chapter-item "><a href="control-flow/for-expressions.html"><strong aria-hidden="true">21.4.</strong> for expressions</a></li><li class="chapter-item "><a href="control-flow/loop-expressions.html"><strong aria-hidden="true">21.5.</strong> loop expressions</a></li><li class="chapter-item "><a href="control-flow/match-expressions.html"><strong aria-hidden="true">21.6.</strong> match expressions</a></li><li class="chapter-item "><a href="control-flow/break-continue.html"><strong aria-hidden="true">21.7.</strong> break & continue</a></li></ol></li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">22.</strong> Standard Library</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/option-result.html"><strong aria-hidden="true">22.1.</strong> Option and Result</a></li><li class="chapter-item "><a href="std/string.html"><strong aria-hidden="true">22.2.</strong> String</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">22.3.</strong> Vec</a></li><li class="chapter-item "><a href="std/hashmap.html"><strong aria-hidden="true">22.4.</strong> HashMap</a></li><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">22.5.</strong> Box</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box-recursive.html"><strong aria-hidden="true">22.5.1.</strong> Recursive Data Types</a></li><li class="chapter-item "><a href="std/box-niche.html"><strong aria-hidden="true">22.5.2.</strong> Niche Optimization</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">22.6.</strong> Rc</a></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">23.</strong> Modules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">23.1.</strong> Visibility</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">23.2.</strong> Paths</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">23.3.</strong> Filesystem Hierarchy</a></li></ol></li><li class="chapter-item "><a href="exercises/course-4/afternoon.html"><strong aria-hidden="true">24.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-4/luhn.html"><strong aria-hidden="true">24.1.</strong> Luhn Algorithm</a></li><li class="chapter-item "><a href="exercises/course-4/strings-iterators.html"><strong aria-hidden="true">24.2.</strong> Strings and Iterators</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 5</li><li class="spacer"></li><li class="chapter-item "><a href="course-5.html"><strong aria-hidden="true">25.</strong> Welcome</a></li><li class="chapter-item "><a href="traits.html"><strong aria-hidden="true">26.</strong> Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/deriving-traits.html"><strong aria-hidden="true">26.1.</strong> Deriving Traits</a></li><li class="chapter-item "><a href="traits/default-methods.html"><strong aria-hidden="true">26.2.</strong> Default Methods</a></li><li class="chapter-item "><a href="traits/important-traits.html"><strong aria-hidden="true">26.3.</strong> Important Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/iterator.html"><strong aria-hidden="true">26.3.1.</strong> Iterator</a></li><li class="chapter-item "><a href="traits/from-iterator.html"><strong aria-hidden="true">26.3.2.</strong> FromIterator</a></li><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">26.3.3.</strong> From and Into</a></li><li class="chapter-item "><a href="traits/read-write.html"><strong aria-hidden="true">26.3.4.</strong> Read and Write</a></li><li class="chapter-item "><a href="traits/operators.html"><strong aria-hidden="true">26.3.5.</strong> Add, Mul, ...</a></li><li class="chapter-item "><a href="traits/drop.html"><strong aria-hidden="true">26.3.6.</strong> Drop</a></li></ol></li></ol></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">27.</strong> Generics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/data-types.html"><strong aria-hidden="true">27.1.</strong> Generic Data Types</a></li><li class="chapter-item "><a href="generics/methods.html"><strong aria-hidden="true">27.2.</strong> Generic Methods</a></li><li class="chapter-item "><a href="generics/trait-bounds.html"><strong aria-hidden="true">27.3.</strong> Trait Bounds</a></li><li class="chapter-item "><a href="generics/impl-trait.html"><strong aria-hidden="true">27.4.</strong> impl Trait</a></li><li class="chapter-item "><a href="generics/closures.html"><strong aria-hidden="true">27.5.</strong> Closures</a></li><li class="chapter-item "><a href="generics/monomorphization.html"><strong aria-hidden="true">27.6.</strong> Monomorphization</a></li><li class="chapter-item "><a href="generics/trait-objects.html"><strong aria-hidden="true">27.7.</strong> Trait Objects</a></li></ol></li><li class="chapter-item "><a href="exercises/course-5/morning.html"><strong aria-hidden="true">28.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-5/simple-gui.html"><strong aria-hidden="true">28.1.</strong> A Simple GUI Library</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 6</li><li class="spacer"></li><li class="chapter-item "><a href="course-6.html"><strong aria-hidden="true">29.</strong> Welcome</a></li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">30.</strong> Error Handling</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">30.1.</strong> Panics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panic-unwind.html"><strong aria-hidden="true">30.1.1.</strong> Catching Stack Unwinding</a></li></ol></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">30.2.</strong> Structured Error Handling</a></li><li class="chapter-item "><a href="error-handling/try-operator.html"><strong aria-hidden="true">30.3.</strong> Propagating Errors with ?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types.html"><strong aria-hidden="true">30.3.1.</strong> Converting Error Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types-example.html"><strong aria-hidden="true">30.3.1.1.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="error-handling/deriving-error-enums.html"><strong aria-hidden="true">30.3.2.</strong> Deriving Error Enums</a></li><li class="chapter-item "><a href="error-handling/dynamic-errors.html"><strong aria-hidden="true">30.3.3.</strong> Dynamic Error Types</a></li><li class="chapter-item "><a href="error-handling/error-contexts.html"><strong aria-hidden="true">30.3.4.</strong> Adding Context to Errors</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">31.</strong> Testing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">31.1.</strong> Unit Tests</a></li><li class="chapter-item "><a href="testing/test-modules.html"><strong aria-hidden="true">31.2.</strong> Test Modules</a></li><li class="chapter-item "><a href="testing/doc-tests.html"><strong aria-hidden="true">31.3.</strong> Documentation Tests</a></li><li class="chapter-item "><a href="testing/integration-tests.html"><strong aria-hidden="true">31.4.</strong> Integration Tests</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">32.</strong> Unsafe Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/raw-pointers.html"><strong aria-hidden="true">32.1.</strong> Dereferencing Raw Pointers</a></li><li class="chapter-item "><a href="unsafe/mutable-static-variables.html"><strong aria-hidden="true">32.2.</strong> Mutable Static Variables</a></li><li class="chapter-item "><a href="unsafe/unions.html"><strong aria-hidden="true">32.3.</strong> Unions</a></li><li class="chapter-item "><a href="unsafe/calling-unsafe-functions.html"><strong aria-hidden="true">32.4.</strong> Calling Unsafe Functions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/writing-unsafe-functions.html"><strong aria-hidden="true">32.4.1.</strong> Writing Unsafe Functions</a></li><li class="chapter-item "><a href="unsafe/extern-functions.html"><strong aria-hidden="true">32.4.2.</strong> Extern Functions</a></li></ol></li><li class="chapter-item "><a href="unsafe/unsafe-traits.html"><strong aria-hidden="true">32.5.</strong> Implementing Unsafe Traits</a></li></ol></li><li class="chapter-item "><a href="exercises/course-6/afternoon.html"><strong aria-hidden="true">33.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-6/safe-ffi-wrapper.html"><strong aria-hidden="true">33.1.</strong> Safe FFI Wrapper</a></li></ol></li><li class="chapter-item "><li class="part-title">Course 7</li><li class="spacer"></li><li class="chapter-item "><a href="course-7.html"><strong aria-hidden="true">34.</strong> Welcome</a></li><li class="chapter-item "><a href="concurrency.html"><strong aria-hidden="true">35.</strong> Concurrency</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">35.1.</strong> Threads</a></li><li class="chapter-item "><a href="concurrency/scoped-threads.html"><strong aria-hidden="true">35.2.</strong> Scoped Threads</a></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">35.3.</strong> Channels</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">35.3.1.</strong> Unbounded Channels</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">35.3.2.</strong> Bounded Channels</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared_state.html"><strong aria-hidden="true">35.4.</strong> Shared State</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared_state/arc.html"><strong aria-hidden="true">35.4.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared_state/mutex.html"><strong aria-hidden="true">35.4.2.</strong> Mutex</a></li><li class="chapter-item "><a href="concurrency/shared_state/example.html"><strong aria-hidden="true">35.4.3.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">35.5.</strong> Send and Sync</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">35.5.1.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">35.5.2.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">35.5.3.</strong> Examples</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/course-7/morning.html"><strong aria-hidden="true">36.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/course-7/dining-philosophers.html"><strong aria-hidden="true">36.1.</strong> Dining Philosophers</a></li><li class="chapter-item "><a href="exercises/course-7/link-checker.html"><strong aria-hidden="true">36.2.</strong> Multi-threaded Link Checker</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust-LINFO2315 (adapted from Comprehensive Rust ü¶Ä)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cpelsser/rust-mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-rust"><a class="header" href="#welcome-to-rust">Welcome to Rust</a></h1>
<h1 id="adapted-from-comprehensive-rust-"><a class="header" href="#adapted-from-comprehensive-rust-">(Adapted from Comprehensive Rust) ü¶Ä</a></h1>
<p>The goal of the course is to teach you Rust. We assume you don‚Äôt know anything
about Rust and hope to:</p>
<ul>
<li>Give you a comprehensive understanding of the Rust syntax and language.</li>
<li>Enable you to modify existing programs</li>
<li>Write new programs in Rust for embedded systems</li>
<li>Show interoperability with C</li>
</ul>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>The course assumes that you already know how to program. Rust is a statically
typed language and we will sometimes make comparisons with C and C++ to better
explain or contrast the Rust approach.</p>
<p>If you know how to program in a dynamically typed language such as Python or
JavaScript, then you will be able to follow along just fine too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-structure"><a class="header" href="#course-structure">Course Structure</a></h1>
<p>The course is fast paced and covers a lot of ground:</p>
<ul>
<li>Course 1: Basic Rust.</li>
<li>Course 2: Ownership and the borrow checker.</li>
<li>Course 3: Compound data types,  pattern matching.</li>
<li>Course 4: The standard library.</li>
<li>Course 5: Traits and generics, error handling</li>
<li>Course 6: Testing, unsafe Rust.</li>
<li>Course 7: Concurrency in Rust and interoperability with other languages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard Shortcuts</a></h1>
<p>There are several useful keyboard shortcuts in mdBook:</p>
<ul>
<li><kbd>Arrow-Left</kbd>: Navigate to the previous page.</li>
<li><kbd>Arrow-Right</kbd>: Navigate to the next page.</li>
<li><kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.</li>
<li><kbd>s</kbd>: Activate the search bar.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-cargo"><a class="header" href="#using-cargo">Using Cargo</a></h1>
<p>When you start reading about Rust, you will soon meet <a href="https://doc.rust-lang.org/cargo/">Cargo</a>, the standard tool
used in the Rust ecosystem to build and run Rust applications. Here we want to
give a brief overview of what Cargo is and how it fits into the wider ecosystem
and how it fits into this training.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="rustup-recommended"><a class="header" href="#rustup-recommended">Rustup (Recommended)</a></h3>
<p>You can follow the instructions to install cargo and rust compiler, among other standard ecosystem tools with the <a href="https://rustup.rs/">rustup</a> tool, which is maintained by the Rust Foundation.</p>
<p>Along with cargo and rustc, Rustup will install itself as a command line utility that you can use to install/switch toolchains, setup cross compilation, etc.</p>
<h3 id="package-managers"><a class="header" href="#package-managers">Package Managers</a></h3>
<h4 id="debian"><a class="header" href="#debian">Debian</a></h4>
<p>On Debian/Ubuntu, you can install Cargo, the Rust source and the <a href="https://github.com/rust-lang/rustfmt">Rust formatter</a> with</p>
<pre><code class="language-shell">$ sudo apt install cargo rust-src rustfmt
</code></pre>
<p>This will allow <a href="https://rust-analyzer.github.io/">rust-analyzer</a> to jump to the definitions. We suggest using
<a href="https://code.visualstudio.com/">VS Code</a> to edit the code (but any LSP compatible editor works).</p>
<p>Some folks also like to use the <a href="https://www.jetbrains.com/clion/">JetBrains</a> family of IDEs, which do their own analysis but have their own tradeoffs. If you prefer them, you can install the <a href="https://www.jetbrains.com/rust/">Rust Plugin</a>. Please take note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rust-ecosystem"><a class="header" href="#the-rust-ecosystem">The Rust Ecosystem</a></h1>
<p>The Rust ecosystem consists of a number of tools, of which the main ones are:</p>
<ul>
<li>
<p><code>rustc</code>: the Rust compiler which turns <code>.rs</code> files into binaries and other
intermediate formats.</p>
</li>
<li>
<p><code>cargo</code>: the Rust dependency manager and build tool. Cargo knows how to
download dependencies hosted on <a href="https://crates.io">https://crates.io</a> and it will pass them to
<code>rustc</code> when building your project. Cargo also comes with a built-in test
runner which is used to execute unit tests.</p>
</li>
<li>
<p><code>rustup</code>: the Rust toolchain installer and updater. This tool is used to
install and update <code>rustc</code> and <code>cargo</code> when new versions of Rust is released.
In addition, <code>rustup</code> can also download documentation for the standard
library. You can have multiple versions of Rust installed at once and <code>rustup</code>
will let you switch between them as needed.</p>
</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Rust has a rapid release schedule with a new release coming out
every six weeks. New releases maintain backwards compatibility with
old releases ‚Äî plus they enable new functionality.</p>
</li>
<li>
<p>There are three release channels: ‚Äústable‚Äù, ‚Äúbeta‚Äù, and ‚Äúnightly‚Äù.</p>
</li>
<li>
<p>New features are being tested on ‚Äúnightly‚Äù, ‚Äúbeta‚Äù is what becomes
‚Äústable‚Äù every six weeks.</p>
</li>
<li>
<p>Rust also has <a href="https://doc.rust-lang.org/edition-guide/">editions</a>: the current edition is Rust 2021. Previous
editions were Rust 2015 and Rust 2018.</p>
<ul>
<li>
<p>The editions are allowed to make backwards incompatible changes to
the language.</p>
</li>
<li>
<p>To prevent breaking code, editions are opt-in: you select the
edition for your crate via the <code>Cargo.toml</code> file.</p>
</li>
<li>
<p>To avoid splitting the ecosystem, Rust compilers can mix code
written for different editions.</p>
</li>
<li>
<p>Mention that it is quite rare to ever use the compiler directly not through <code>cargo</code> (most users never do).</p>
</li>
<li>
<p>It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  It is capable of many advanced features including but not limited to: </p>
<ul>
<li>Project/package structure</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">workspaces</a></li>
<li>Dev Dependencies and Runtime Dependency management/caching</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripting</a></li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">global installation</a></li>
<li>It is also extensible with sub command plugins as well (such as <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>).</li>
</ul>
</li>
<li>
<p>Read more from the <a href="https://doc.rust-lang.org/cargo/">official Cargo Book</a></p>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-samples-in-this-training"><a class="header" href="#code-samples-in-this-training">Code Samples in This Training</a></h1>
<p>For this training, we will mostly explore the Rust language through examples
which can be executed through your browser. This makes the setup much easier and
ensures a consistent experience for everyone.</p>
<p>Installing Cargo is still encouraged: it will make it easier for you to do the
exercises. On the last day, we will do a larger exercise which shows you how to
work with dependencies and for that you need Cargo.</p>
<p>The code blocks in this course are fully interactive:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
<p>You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the
text box.</p>
<details>
<p>Most code samples are editable like shown above. A few code samples
are not editable for various reasons:</p>
<ul>
<li>
<p>The embedded playgrounds cannot execute unit tests. Copy-paste the
code and open it in the real Playground to demonstrate unit tests.</p>
</li>
<li>
<p>The embedded playgrounds lose their state the moment you navigate
away from the page! This is the reason that the students should
solve the exercises using a local Rust installation or via the
Playground.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-code-locally-with-cargo"><a class="header" href="#running-code-locally-with-cargo">Running Code Locally with Cargo</a></h1>
<p>If you want to experiment with the code on your own system, then you will need
to first install Rust. Do this by following the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">instructions in the Rust
Book</a>. This should give you a working <code>rustc</code> and <code>cargo</code>. At the time of
writing, the latest stable Rust release has these version numbers:</p>
<pre><code class="language-shell">% rustc --version
rustc 1.61.0 (fe5b13d68 2022-05-18)
% cargo --version
cargo 1.61.0 (a028ae4 2022-04-29)
</code></pre>
<p>With this is in place, then follow these steps to build a Rust binary from one
of the examples in this training:</p>
<ol>
<li>
<p>Click the ‚ÄúCopy to clipboard‚Äù button on the example you want to copy.</p>
</li>
<li>
<p>Use <code>cargo new exercise</code> to create a new <code>exercise/</code> directory for your code:</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>Navigate into <code>exercise/</code> and use <code>cargo run</code> to build and run your binary:</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>Replace the boiler-plate code in <code>src/main.rs</code> with your own code. For
example, using the example on the previous page, make <code>src/main.rs</code> look like</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>Use <code>cargo run</code> to build and run your updated binary:</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>Use <code>cargo check</code> to quickly check your project for errors, use <code>cargo build</code>
to compile it without running it. You will find the output in <code>target/debug/</code>
for a normal debug build. Use <code>cargo build --release</code> to produce an optimized
release build in <code>target/release/</code>.</p>
</li>
<li>
<p>You can add dependencies for your project by editing <code>Cargo.toml</code>. When you
run <code>cargo</code> commands, it will automatically download and compile missing
dependencies for you.</p>
</li>
</ol>
<details>
<p>Try to encourage the class participants to install Cargo and use a
local editor. It will make their life easier since they will have a
normal development environment.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-1"><a class="header" href="#welcome-to-course-1">Welcome to course 1</a></h1>
<p>In this first session we will cover:</p>
<ul>
<li>Basic Rust syntax: variables, scalar and compound types, enums, structs,
references, functions, and methods.</li>
</ul>
<!-- * Memory management: stack vs heap, manual memory management, scope-based memory
  management, and garbage collection.

* Ownership: move semantics, copying and cloning, borrowing, and lifetimes.
 -->
<!-- <details>

Please remind the students that:

* They should ask questions when they get them, don't save them to the end.
* The class is meant to be interactive and discussions are very much encouraged!
  * As an instructor, you should try to keep the discussions relevant, i.e.,
    keep the related to how Rust does things vs some other language. It can be
    hard to find the right balance, but err on the side of allowing discussions
    since they engage people much more than one-way communication.
* The questions will likely mean that we about things ahead of the slides.
  * This is perfectly okay! Repetition is an important part of learning. Remember
    that the slides are just a support and you are free to skip them as you
    like.

The idea for the first day is to show _just enough_ of Rust to be able to speak
about the famous borrow checker. The way Rust handles memory is a major feature
and we should show students this right away.

If you're teaching this in a classroom, this is a good place to go over the
schedule. We suggest splitting the day into two parts (following the slides):

* Morning: 9:00 to 12:00,
* Afternoon: 13:00 to 16:00.

You can of course adjust this as necessary. Please make sure to include breaks,
we recommend a break every hour!

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-rust"><a class="header" href="#what-is-rust">What is Rust?</a></h1>
<p>Rust is a new programming language which had its <a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 release in 2015</a>:</p>
<ul>
<li>Rust is a statically compiled language in a similar role as C++
<ul>
<li><code>rustc</code> uses LLVM as its backend.</li>
</ul>
</li>
<li>Rust supports many <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms and
architectures</a>:
<ul>
<li>x86, ARM, WebAssembly, ‚Ä¶</li>
<li>Linux, Mac, Windows, ‚Ä¶</li>
</ul>
</li>
<li>Rust is used for a wide range of devices:
<ul>
<li>firmware and boot loaders,</li>
<li>smart displays,</li>
<li>mobile phones,</li>
<li>desktops,</li>
<li>servers.</li>
</ul>
</li>
</ul>
<details>
<p>Rust fits in the same area as C++:</p>
<ul>
<li>High flexibility.</li>
<li>High level of control.</li>
<li>Can be scaled down to very constrained devices like mobile phones.</li>
<li>Has no runtime or garbage collection.</li>
<li>Focuses on reliability and safety without sacrificing performance.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Let us jump into the simplest possible Rust program, a classic Hello World
program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Hello üåç!&quot;);
}
</code></pre></pre>
<p>What you see:</p>
<ul>
<li>Functions are introduced with <code>fn</code>.</li>
<li>Blocks are delimited by curly braces like in C and C++.</li>
<li>The <code>main</code> function is the entry point of the program.</li>
<li>Rust has hygienic macros, <code>println!</code> is an example of this.</li>
<li>Rust strings are UTF-8 encoded and can contain any Unicode character.</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see
a ton of it over the next four days so we start small with something familiar.</p>
<p>Key points:</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is
imperative (not functional) and it doesn‚Äôt try to reinvent things unless
absolutely necessary.</p>
</li>
<li>
<p>Rust is modern with full support for things like Unicode.</p>
</li>
<li>
<p>Rust uses macros for situations where you want to have a variable number of
arguments (no function <a href="basic-syntax/functions-interlude.html">overloading</a>).</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="small-example"><a class="header" href="#small-example">Small Example</a></h1>
<p>Here is a small example program in Rust:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {              // Program entry point
    let mut x: i32 = 6;  // Mutable variable binding
    print!(&quot;{x}&quot;);       // Macro for printing, like printf
    while x != 1 {       // No parenthesis around expression
        if x % 2 == 0 {  // Math like in other languages
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        print!(&quot; -&gt; {x}&quot;);
    }
    println!();
}
</code></pre></pre>
<details>
<p>The code implements the Collatz conjecture: it is believed that the loop will
always end, but this is not yet proved. Edit the code and play with different
inputs.</p>
<p>Key points:</p>
<ul>
<li>
<p>Explain that all variables are statically typed. Try removing <code>i32</code> to trigger
type inference. Try with <code>i8</code> instead and trigger a runtime integer overflow.</p>
</li>
<li>
<p>Change <code>let mut x</code> to <code>let x</code>, discuss the compiler error.</p>
</li>
<li>
<p>Show how <code>print!</code> gives a compilation error if the arguments don‚Äôt match the
format string.</p>
</li>
<li>
<p>Show how you need to use <code>{}</code> as a placeholder if you want to print an
expression which is more complex than just a single variable.</p>
</li>
<li>
<p>Show the students the standard library, show them how to search for <code>std::fmt</code>
which has the rules of the formatting mini-language. It‚Äôs important that the
students become familiar with searching in the standard library.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h1>
<p>Some unique selling points of Rust:</p>
<ul>
<li>Compile time memory safety.</li>
<li>Lack of undefined runtime behavior.</li>
<li>Modern language features.</li>
</ul>
<details>
<p>Make sure to ask the class which languages they have experience with. Depending
on the answer you can highlight different features of Rust:</p>
<ul>
<li>
<p>Experience with C or C++: Rust eliminates a whole class of <em>runtime errors</em>
via the borrow checker. You get performance like in C and C++, but you don‚Äôt
have the memory unsafety issues. In addition, you get a modern language with
constructs like pattern matching and built-in dependency management.</p>
</li>
<li>
<p>Experience with Java, Go, Python, JavaScript‚Ä¶: You get the same memory safety
as in those languages, plus a similar high-level language feeling. In addition
you get fast and predictable performance like C and C++ (no garbage collector)
as well as access to low-level hardware (should you need it)</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-guarantees"><a class="header" href="#compile-time-guarantees">Compile Time Guarantees</a></h1>
<p>Static memory management at compile time:</p>
<ul>
<li>No uninitialized variables.</li>
<li>No memory leaks (<em>mostly</em>, see notes).</li>
<li>No double-frees.</li>
<li>No use-after-free.</li>
<li>No <code>NULL</code> pointers.</li>
<li>No forgotten locked mutexes.</li>
<li>No data races between threads.</li>
<li>No iterator invalidation.</li>
</ul>
<details>
<p>It is possible to produce memory leaks in (safe) Rust. Some examples
are:</p>
<ul>
<li>You can for use <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> to leak a pointer. A use of this could
be to get runtime-initialized and runtime-sized static variables</li>
<li>You can use <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> to make the compiler ‚Äúforget‚Äù about
a value (meaning the destructor is never run).</li>
<li>You can also accidentally create a <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycle</a> with <code>Rc</code> or
<code>Arc</code>.</li>
<li>In fact, some will consider infinitely populating a collection a memory
leak and Rust does not protect from those.</li>
</ul>
<p>For the purpose of this course, ‚ÄúNo memory leaks‚Äù should be understood
as ‚ÄúPretty much no <em>accidental</em> memory leaks‚Äù.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-guarantees"><a class="header" href="#runtime-guarantees">Runtime Guarantees</a></h1>
<p>No undefined behavior at runtime:</p>
<ul>
<li>Array access is bounds checked.</li>
<li>Integer overflow is defined.</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Integer overflow is defined via a compile-time flag. The options are
either a panic (a controlled crash of the program) or wrap-around
semantics. By default, you get panics in debug mode (<code>cargo build</code>)
and wrap-around in release mode (<code>cargo build --release</code>).</p>
</li>
<li>
<p>Bounds checking cannot be disabled with a compiler flag. It can also
not be disabled directly with the <code>unsafe</code> keyword. However,
<code>unsafe</code> allows you to call functions such as <code>slice::get_unchecked</code>
which does not do bounds checking.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-features"><a class="header" href="#modern-features">Modern Features</a></h1>
<p>Rust is built with all the experience gained in the last 40 years.</p>
<!-- ## Language Features

* Enums and pattern matching.
* Generics.
* No overhead FFI (Foreign Function Interface).
* Zero-cost abstractions. -->
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<ul>
<li>Great compiler errors.</li>
<li>Built-in dependency manager.</li>
<li>Built-in support for testing.</li>
<li>Excellent Language Server Protocol support.</li>
</ul>
<details>
<p>Key points:</p>
<!-- * Zero-cost abstractions, similar to C++, means that you don't have to 'pay'
  for higher-level programming constructs with memory or CPU. For example,
  writing a loop using `for` should result in roughly the same low level
  instructions as using the `.iter().fold()` construct.

* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also
  known as 'sum types', which allow the type system to express things like
  `Option<T>` and `Result<T, E>`. -->
<ul>
<li>
<p>Remind people to read the errors ‚Äî many developers have gotten used to
ignore lengthy compiler output. The Rust compiler is significantly more
talkative than other compilers. It will often provide you with <em>actionable</em>
feedback, ready to copy-paste into your code.</p>
</li>
<li>
<p>The Rust standard library is small compared to languages like Java, Python,
and Go. Rust does not come with several things you might consider standard and
essential:</p>
<ul>
<li>a random number generator, but see <a href="https://docs.rs/rand/">rand</a>.</li>
<li>support for SSL or TLS, but see <a href="https://docs.rs/rustls/">rusttls</a>.</li>
<li>support for JSON, but see <a href="https://docs.rs/serde_json/">serde_json</a>.
The reasoning behind this is that functionality in the standard library cannot
go away, so it has to be very stable. For the examples above, the Rust
community is still working on finding the best solution ‚Äî and perhaps there
isn‚Äôt a single ‚Äúbest solution‚Äù for some of these things.</li>
</ul>
<p>Rust comes with a built-in package manager in the form of Cargo and this makes
it trivial to download and compile third-party crates. A consequence of this
is that the standard library can be smaller.</p>
<p>Discovering good third-party crates can be a problem. Sites like
<a href="https://lib.rs/">https://lib.rs/</a> help with this by letting you compare health metrics for
crates to find a good and trusted one.</p>
</li>
<li>
<p><a href="https://rust-analyzer.github.io/">rust-analyzer</a> is a well supported LSP implementation used in major
IDEs and text editors.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h1>
<p>Much of the Rust syntax will be familiar to you from C, C++ or Java:</p>
<ul>
<li>Blocks and scopes are delimited by curly braces.</li>
<li>Line comments are started with <code>//</code>, block comments are delimited by <code>/* ... */</code>.</li>
<li>Keywords like <code>if</code> and <code>while</code> work the same.</li>
<li>Variable assignment is done with <code>=</code>, comparison is done with <code>==</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expressions"><a class="header" href="#if-expressions">If expressions</a></h1>
<p>You use
<a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> expressions</a>
exactly like <code>if</code> statements in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 10;
    if x &lt; 20 {
        println!(&quot;small&quot;);
    } else if x &lt; 100 {
        println!(&quot;biggish&quot;);
    } else {
        println!(&quot;huge&quot;);
    }
}
</code></pre></pre>
<p>In addition, you can use <code>if</code> as an expression. The last expression of each
block becomes the value of the <code>if</code> expression:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 10;
    let size = if x &lt; 20 { &quot;small&quot; } else { &quot;large&quot; };
    println!(&quot;number size: {}&quot;, size);
}
</code></pre></pre>
<details>
<p>Because <code>if</code> is an expression and must have a particular type, both of its
branch blocks must have the same type. Show what happens if you add <code>;</code> after
<code>&quot;small&quot;</code> in the second example.</p>
<p>When <code>if</code> is used in an expression, the expression must have a <code>;</code> to separate
it from the next statement. Remove the <code>;</code> before <code>println!</code> to see the compiler
error.</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Signed integers</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123i64</code></td></tr>
<tr><td>Unsigned integers</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10u16</code></td></tr>
<tr><td>Floating point numbers</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2f32</code></td></tr>
<tr><td>Strings</td><td><code>&amp;str</code></td><td><code>&quot;foo&quot;</code>, <code>r#&quot;\\&quot;#</code></td></tr>
<tr><td>Unicode scalar values</td><td><code>char</code></td><td><code>'a'</code>, <code>'Œ±'</code>, <code>'‚àû'</code></td></tr>
<tr><td>Byte strings</td><td><code>&amp;[u8]</code></td><td><code>b&quot;abc&quot;</code>, <code>br#&quot; &quot; &quot;#</code></td></tr>
<tr><td>Booleans</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
</div>
<p>The types have widths as follows:</p>
<ul>
<li><code>iN</code>, <code>uN</code>, and <code>fN</code> are <em>N</em> bits wide,</li>
<li><code>isize</code> and <code>usize</code> are the width of a pointer,</li>
<li><code>char</code> is 32 bit wide,</li>
<li><code>bool</code> is 8 bit wide.</li>
</ul>
<details>
	r is used to denote raw string literals. Raw string literals do not process any escapes.
	It is followed by (#)+, then ", the litteral, " and (#)+<br>
<pre><code>r#&quot;&quot;foo&quot;&quot;#; stands for &quot;foo&quot;

r##&quot;foo #&quot;# bar&quot;##; stands for foo #&quot;# bar
</code></pre>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Arrays</td><td><code>[T; N]</code></td><td><code>[20, 30, 40]</code>, <code>[0; 3]</code></td></tr>
<tr><td>Tuples</td><td><code>()</code>, <code>(T,)</code>, <code>(T1, T2)</code>, ‚Ä¶</td><td><code>()</code>, <code>('x',)</code>, <code>('x', 1.2)</code>, ‚Ä¶</td></tr>
</tbody></table>
</div>
<p>Array assignment and access:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {:?}&quot;, a);
}
</code></pre></pre>
<p>Tuple assignment and access:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;1st index: {}&quot;, t.0);
    println!(&quot;2nd index: {}&quot;, t.1);
}
</code></pre></pre>
<details>
<p>Key points:</p>
<p>Arrays:</p>
<ul>
<li>
<p>Arrays have elements of the same type, <code>T</code>, and length, <code>N</code>, which is a compile-time constant.
Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and
<code>[u8; 4]</code> are considered two different types.</p>
</li>
<li>
<p>We can use literals to assign values to arrays.</p>
</li>
<li>
<p>In the main function, the print statement asks for the debug implementation with the <code>?</code> format
parameter: <code>{}</code> gives the default output, <code>{:?}</code> gives the debug output. We
could also have used <code>{a}</code> and <code>{a:?}</code> without specifying the value after the
format string.</p>
</li>
<li>
<p>Adding <code>#</code>, eg <code>{a:#?}</code>, invokes a ‚Äúpretty printing‚Äù format, which can be easier to read.</p>
</li>
</ul>
<p>Tuples:</p>
<ul>
<li>
<p>Like arrays, tuples have a fixed length.</p>
</li>
<li>
<p>Tuples group together values of different types into a compound type.</p>
</li>
<li>
<p>Fields of a tuple can be accessed by the period and the index of the value, e.g. <code>t.0</code>, <code>t.1</code>.</p>
</li>
<li>
<p>The empty tuple <code>()</code> is also known as the ‚Äúunit type‚Äù. It is both a type, and
the only valid value of that type - that is to say both the type and its value
are expressed as <code>()</code>. It is used to indicate, for example, that a function or
expression has no return value, as we‚Äôll see in a future slide. </p>
<ul>
<li>You can think of it as <code>void</code> that can be familiar to you from other 
programming languages.</li>
</ul>
</li>
</ul>
<p>T is a generic type</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Like C++, Rust has references:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x: i32 = 10;
    let ref_x: &amp;mut i32 = &amp;mut x;
    *ref_x = 20;
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>Some notes:</p>
<ul>
<li>We must dereference <code>ref_x</code> when assigning to it, similar to C and C++ pointers.</li>
<li>Rust will auto-dereference in some cases, in particular when invoking
methods (try <code>ref_x.count_ones()</code>).</li>
<li>References that are declared as <code>mut</code> can be bound to different values over their lifetime.</li>
</ul>
<details>
Key points:
<ul>
<li>Be sure to note the difference between <code>let mut ref_x: &amp;i32</code> and <code>let ref_x: &amp;mut i32</code>. The first one represents a mutable reference which can be bound to
different values, while the second represents a reference to a mutable value.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h1>
<p>Rust will statically forbid dangling references:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let ref_x: &amp;i32;
    {
        let x: i32 = 10;
        ref_x = &amp;x;
    }
    println!(&quot;ref_x: {ref_x}&quot;);
}
</code></pre></pre>
<ul>
<li>A reference is said to ‚Äúborrow‚Äù the value it refers to.</li>
<li>Rust is tracking the lifetimes of all references to ensure they live long
enough.</li>
<li>We will talk more about borrowing when we get to ownership.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p>A slice gives you a view into a larger collection:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];
    println!(&quot;s: {s:?}&quot;);
}
</code></pre></pre>
<ul>
<li>Slices borrow data from the sliced type.</li>
<li>Question: What happens if you modify <code>a[3]</code>?</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain ‚Äòalive‚Äô (in scope) for at least as long as our slice. </p>
</li>
<li>
<p>The question about modifying <code>a[3]</code> can spark an interesting discussion, but the answer is that for memory safety reasons
you cannot do it through <code>a</code> after you created a slice, but you can read the data from both <code>a</code> and <code>s</code> safely. 
More details will be explained in the borrow checker section.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-vs-str"><a class="header" href="#string-vs-str"><code>String</code> vs <code>str</code></a></h1>
<p>We can now understand the two string types in Rust:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
    
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<p>Rust terminology:</p>
<ul>
<li><code>&amp;str</code> an immutable reference to a string slice.</li>
<li><code>String</code> a mutable string buffer.</li>
</ul>
<details>
<ul>
<li>
<p><code>&amp;str</code> introduces a string slice, which is an immutable reference to UTF-8 encoded string data 
stored in a block of memory. String literals (<code>‚ÄùHello‚Äù</code>), are stored in the program‚Äôs binary.</p>
</li>
<li>
<p>Rust‚Äôs <code>String</code> type is a wrapper around a vector of bytes. As with a <code>Vec&lt;T&gt;</code>, it is owned.
<code>Vec&lt;T&gt;</code> is an array that changes size dynamically.</p>
</li>
<li>
<p>As with many other types <code>String::from()</code> creates a string from a string literal; <code>String::new()</code> 
creates a new empty string, to which string data can be added using the <code>push()</code> and <code>push_str()</code> methods.</p>
</li>
<li>
<p>The <code>format!()</code> macro is a convenient way to generate an owned string from dynamic values. It 
accepts the same format specification as <code>println!()</code>.</p>
</li>
<li>
<p>You can borrow <code>&amp;str</code> slices from <code>String</code> via <code>&amp;</code> and optionally range selection.</p>
</li>
<li>
<p>For C++ programmers: think of <code>&amp;str</code> as <code>const char*</code> from C++, but the one that always points 
to a valid string in memory. Rust <code>String</code> is a rough equivalent of <code>std::string</code> from C++ 
(main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).</p>
</li>
<li>
<p>How do I modify s1? Here is an example built by iteratively following the guidelines of the compiler. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);
    let binding  = &amp;(s1.to_owned() + &quot; hobbit&quot;);
    s1 = &amp;binding;

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
  
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>A Rust version of the famous <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> interview question:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    fizzbuzz_to(20);   // Defined below, no forward declaration needed
}

fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;  // Corner case, early return
    }
    lhs % rhs == 0     // The last expression in a block is the return value
}

fn fizzbuzz(n: u32) -&gt; () {  // No return value means returning the unit type `()`
    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {
        (true,  true)  =&gt; println!(&quot;fizzbuzz&quot;),
        (true,  false) =&gt; println!(&quot;fizz&quot;),
        (false, true)  =&gt; println!(&quot;buzz&quot;),
        (false, false) =&gt; println!(&quot;{n}&quot;),
    }
}

fn fizzbuzz_to(n: u32) {  // `-&gt; ()` is normally omitted
    for i in 1..=n {
        fizzbuzz(i);
    }
}
</code></pre></pre>
<p>In FizzBuzz, players take turns to count incrementally, replacing any number divisible by three with the word ‚Äúfizz‚Äù, and any number divisible by five with the word ‚Äúbuzz‚Äù, and any number divisible by both 3 and 5 with the word ‚Äúfizzbuzz‚Äù.</p>
<details>
<ul>
<li>
<p>We refer in <code>main</code> to a function written below. Neither forward declarations nor headers are necessary. </p>
</li>
<li>
<p>Declaration parameters are followed by a type (the reverse of some programming languages), then a return type.</p>
</li>
<li>
<p>The last expression in a function body (or any block) becomes the return value. Simply omit the <code>;</code> at the end of the expression.</p>
</li>
<li>
<p>Some functions have no return value, and return the ‚Äòunit type‚Äô, <code>()</code>. The compiler will infer this if the <code>-&gt; ()</code> return type is omitted.</p>
</li>
<li>
<p>The range expression in the <code>for</code> loop in <code>fizzbuzz_to()</code> contains <code>=n</code>, which causes it to include the upper bound.</p>
</li>
<li>
<p>The <code>match</code> expression in <code>fizzbuzz()</code> is doing a lot of work. It is expanded below to show what is happening.</p>
<p>(Type annotations added for clarity, but they can be elided.)</p>
<pre><code class="language-rust ignore">let by_3: bool = is_divisible_by(n, 3);
let by_5: bool = is_divisible_by(n, 5);
let by_35: (bool, bool) = (by_3, by_5);
match by_35 {
  // ...
</code></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>Rust has methods, they are simply functions that are associated with a particular type. The
first argument of a method is an instance of the type it is associated with:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn inc_width(&amp;mut self, delta: u32) {
        self.width += delta;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 5 };
    println!(&quot;old area: {}&quot;, rect.area());
    rect.inc_width(5);
    println!(&quot;new area: {}&quot;, rect.area());
}
</code></pre></pre>
<ul>
<li>We will look much more at methods in this class‚Äô exercise and in the next class.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h1>
<p>Overloading is not supported:</p>
<ul>
<li>Each function has a single implementation:
<ul>
<li>Always takes a fixed number of parameters.</li>
<li>Always takes a single set of parameter types.</li>
</ul>
</li>
<li>Default values are not supported:
<ul>
<li>All call sites have the same number of arguments.</li>
<li>Macros are sometimes used as an alternative.</li>
</ul>
</li>
</ul>
<p>However, function parameters can be generic:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn pick_one&lt;T&gt;(a: T, b: T) -&gt; T {
    if std::process::id() % 2 == 0 { a } else { b }
}

fn main() {
    println!(&quot;coin toss: {}&quot;, pick_one(&quot;heads&quot;, &quot;tails&quot;));
    println!(&quot;cash prize: {}&quot;, pick_one(500, 1000));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>When using generics, the standard library‚Äôs <code>Into&lt;T&gt;</code> can provide a kind of limited
polymorphism on argument types. We will see more details in a later section.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/process/fn.id.html">std::process::id()</a> returns the 
pid of the current process </p>
</li>
</ul>
</defails>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-1-exercises"><a class="header" href="#course-1-exercises">Course 1: Exercises</a></h1>
<p>In these exercises, we will explore two parts of Rust:</p>
<ul>
<li>
<p>Implicit conversions between types.</p>
</li>
<li>
<p>Arrays and <code>for</code> loops.</p>
</li>
</ul>
<details>
<p>A few things to consider while solving the exercises:</p>
<ul>
<li>
<p>Use a local Rust installation, if possible. This way you can get
auto-completion in your editor. See the page about <a href="exercises/course-1/../../cargo.html">Using Cargo</a> for details
on installing Rust.</p>
</li>
<li>
<p>Alternatively, use the Rust Playground.</p>
</li>
</ul>
<p>The code snippets are not editable on purpose: the inline code snippets lose
their state if you navigate away from the page.</p>
<!-- After looking at the exercises, you can look at the [solutions] provided. -->
<!-- [solutions]: solutions-morning.md -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit Conversions</a></h1>
<p>Rust will not automatically apply <em>implicit conversions</em> between types (<a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">unlike
C++</a>). You can see this in a program like this:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn multiply(x: i16, y: i16) -&gt; i16 {
    x * y
}

fn main() {
    let x: i8 = 15;
    let y: i16 = 1000;

    println!(&quot;{x} * {y} = {}&quot;, multiply(x, y));
}
</code></pre></pre>
<p>The Rust integer types all implement the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a>
traits to let us convert between them. The <code>From&lt;T&gt;</code> trait has a single <code>from()</code>
method and similarly, the <code>Into&lt;T&gt;</code> trait has a single <code>into()</code> method.
Implementing these traits is how a type expresses that it can be converted into
another type.</p>
<p>The standard library has an implementation of <code>From&lt;i8&gt; for i16</code>, which means
that we can convert a variable <code>x</code> of type <code>i8</code> to an <code>i16</code> by calling 
<code>i16::from(x)</code>. Or, simpler, with <code>x.into()</code>, because <code>From&lt;i8&gt; for i16</code>
implementation automatically create an implementation of <code>Into&lt;i16&gt; for i8</code>.</p>
<p>The same applies for your own <code>From</code> implementations for your own types, so it is
sufficient to only implement <code>From</code> to get a respective <code>Into</code> implementation automatically.</p>
<ol>
<li>
<p>Execute the above program and look at the compiler error.</p>
</li>
<li>
<p>Update the code above to use <code>into()</code> to do the conversion.</p>
</li>
<li>
<p>Change the types of <code>x</code> and <code>y</code> to other things (such as <code>f32</code>, <code>bool</code>,
<code>i128</code>) to see which types you can convert to which other types. Try
converting small types to big types and the other way around. Check the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html">standard library documentation</a> to see if <code>From&lt;T&gt;</code> is implemented for
the pairs you check.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix-multiplication"><a class="header" href="#matrix-multiplication">Matrix multiplication</a></h1>
<p>Your task is to write a function that performs matrix multiplication in Rust. The function signature should look like this:</p>
<pre><code class="language-rs">fn multiply_matrices(a: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, b: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    // Your code
}
</code></pre>
<p>Your code should check that the matrices have the right dimensions.</p>
<p>There are different ways to represent 2-D arrays in Rust, here we chose the type <code>&amp;Vec&lt;Vec&lt;i32&gt;&gt;</code>. When you finish this exercice, feel free to explore other possible representations (e.g <code>ndarray::arr2</code>).</p>
<p>Usage example:</p>
<pre><code class="language-rs">fn main() {
    let matrix_a = vec![
        vec![1, 2, 3],
        vec![4, 5, 6],
    ];

    let matrix_b = vec![
        vec![7, 8],
        vec![9, 10],
        vec![11, 12],
    ];

    let result_matrix = multiply_matrices(&amp;matrix_a, &amp;matrix_b);

    // Print the result
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-for-loops"><a class="header" href="#arrays-and-for-loops">Arrays and <code>for</code> Loops</a></h1>
<p>We saw that an array can be declared like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [10, 20, 30];
<span class="boring">}
</span></code></pre></pre>
<p>You can print such an array by asking for its debug representation with <code>{:?}</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let array = [10, 20, 30];
    println!(&quot;array: {array:?}&quot;);
}
</code></pre></pre>
<p>Rust lets you iterate over things like arrays and ranges using the <code>for</code>
keyword:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let array = [10, 20, 30];
    print!(&quot;Iterating over array:&quot;);
    for n in array {
        print!(&quot; {n}&quot;);
    }
    println!();

    print!(&quot;Iterating over range:&quot;);
    for i in 0..3 {
        print!(&quot; {}&quot;, array[i]);
    }
    println!();
}
</code></pre></pre>
<p>Use the above to write a function <code>pretty_print</code> which pretty-print a matrix and
a function <code>transpose</code> which will transpose a matrix (turn rows into columns):</p>
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7‚é§</text><text x="250" y="28" >8‚é•</text><text x="250" y="44" >9‚é¶</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">‚éõ</text><text x="98" y="12">‚é°</text><text x="106" y="12">1</text></g><g><text x="90" y="28">‚éú</text><text x="98" y="28">‚é¢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">‚éù</text><text x="98" y="44">‚é£</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3‚é§</text><text x="154" y="12">‚éû</text></g><g><text x="138" y="28">6‚é•</text><text x="154" y="28">‚éü</text></g><g><text x="138" y="44">9‚é¶</text><text x="154" y="44">‚é†</text></g><g><text x="210" y="12">‚é°</text><text x="218" y="12">1</text></g><g><text x="210" y="28">‚é¢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">‚é£</text><text x="218" y="44">3</text></g></svg></div>
<p>Hard-code both functions to operate on 3 √ó 3 matrices.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the
functions:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    unimplemented!()
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}
</code></pre></pre>
<h2 id="bonus-question"><a class="header" href="#bonus-question">Bonus Question</a></h2>
<p>Could you use <code>&amp;[i32]</code> slices instead of hard-coded 3 √ó 3 matrices for your
argument and return types? Something like <code>&amp;[&amp;[i32]]</code> for a two-dimensional
slice-of-slices. Why or why not?</p>
<p>See the <a href="https://docs.rs/ndarray/"><code>ndarray</code> crate</a> for a production quality
implementation.</p>
<!-- <details>

The solution and the answer to the bonus section are available in the 
[Solution](solutions-morning.md#arrays-and-for-loops) section.

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="palindrome"><a class="header" href="#palindrome">Palindrome</a></h1>
<p>Implement a Rust function that determines whether a given string is a palindrome. </p>
<p>A palindrome is a sequence of characters that reads the same forward and backward (e.g. kayak, madam, racecar, ‚Ä¶). </p>
<p>In this exercices we ask you to ignore spaces, punctuation, and case.</p>
<p>Have a look at the <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>std::str</code></a> documentation if needed.</p>
<p>Function signature:</p>
<pre><code class="language-rs">fn is_palindrome(s: &amp;str) -&gt; bool{
    // Your code
}
</code></pre>
<p>Usage example:</p>
<pre><code class="language-rs">fn main() {
    let palindrome1 = &quot;A man, a plan, a canal, Panama&quot;;
    let palindrome2 = &quot;Madam, in Eden, I'm Adam&quot;;
    let non_palindrome = &quot;Having class 8:30am is fun!!&quot;;

    println!(&quot;Is '{}' a palindrome? {}&quot;, palindrome1, is_palindrome(palindrome1)); // True
    println!(&quot;Is '{}' a palindrome? {}&quot;, palindrome2, is_palindrome(palindrome2)); // True
    println!(&quot;Is '{}' a palindrome? {}&quot;, non_palindrome, is_palindrome(non_palindrome)); // False
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-2"><a class="header" href="#welcome-to-course-2">Welcome to course 2</a></h1>
<p>We will cover:</p>
<ul>
<li>
<p>Memory management: stack vs heap, manual memory management, scope-based memory
management, and garbage collection.</p>
</li>
<li>
<p>Ownership: move semantics, copying and cloning, borrowing, and lifetimes.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Rust provides type safety via static typing. Variable bindings are immutable by
default:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Due to type inference the <code>i32</code> is optional. We will gradually show the types less and less as the course progresses.</li>
<li>Note that since <code>println!</code> is a macro, <code>x</code> is not moved, even using the function like syntax of <code>println!(&quot;x: {}&quot;, x)</code></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>Rust will look at how the variable is <em>used</em> to determine the type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
</code></pre></pre>
<details>
<p>This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.</p>
<p>It is very important to emphasize that variables declared like this are not of some sort of dynamic ‚Äúany type‚Äù that can
hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type.
The compiler does the job for us and helps us to write a more concise code.</p>
<p>The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using <code>_</code> as a placeholder:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!(&quot;v: {v:?}&quot;);

    let vv = v.iter().collect::&lt;std::collections::HashSet&lt;_&gt;&gt;();
    println!(&quot;vv: {vv:?}&quot;);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> relies on <code>FromIterator</code>, which <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>HashSet</code></a> implements.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p>Option<type> comes from <code>std::option</code>. It is used to represent an optional value. Option is either <code>Some</code> or <code>None</code>. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

fn main () {
    // The return value of the function is an option
    let result = divide(2.0, 3.0);

    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(x) =&gt; println!(&quot;Result: {x}&quot;),
        // The division was invalid
        None    =&gt; println!(&quot;Cannot divide by 0&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>See <a href="https://doc.rust-lang.org/std/option/">std::option</a> for more info.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-constant-variables"><a class="header" href="#static-and-constant-variables">Static and Constant Variables</a></h1>
<p>Global state is managed with static and constant variables.</p>
<h2 id="const"><a class="header" href="#const"><code>const</code></a></h2>
<p>You can declare compile-time constants:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {

    // println!(&quot;{:?}&quot;, text.as_bytes());
    // println!(&quot;{}&quot;, ZERO.unwrap_or(0));

    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];

    // println!(&quot;{:?}&quot;, digest);

    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {

        // println!(&quot;[{:?}]: {:?}&quot;, idx, &amp;b);
        
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;Digest: {digest:?}&quot;);
}
</code></pre></pre>
<p>According the the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> these are inlined upon use.</p>
<h2 id="static"><a class="header" href="#static"><code>static</code></a></h2>
<p>You can also declare static variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}
</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location.  This is useful for unsafe and embedded code, and the variable lives through the entirety of the program execution.</p>
<p>We will look at mutating static data in the <a href="basic-syntax/../unsafe.html">chapter on Unsafe Rust</a>.</p>
<details>
<ul>
<li><code>pub fn unwrap_or(self, default: T) -&gt; T</code>. Returns the contained <code>Some</code> value or a provided default. Here, ZERO.unwrap_or(0) is equal to 42. It would return 0 if ZERO was equal to None.</li>
<li>Mention that <code>const</code> behaves semantically similar to C++‚Äôs <code>constexpr</code>.</li>
<li><code>static</code>, on the other hand, is much more similar to a <code>const</code> or mutable global variable in C++.</li>
<li>It isn‚Äôt super common that one would need a runtime evaluated constant, but it is helpful and safer than using a static.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scopes-and-shadowing"><a class="header" href="#scopes-and-shadowing">Scopes and Shadowing</a></h1>
<p>You can shadow variables, both those from outer scopes and variables from the
same scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);

    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Definition: Shadowing is different from mutation, because after shadowing both variable‚Äôs memory locations exist at the same time. Both are available under the same name, depending where you use it in the code. </li>
<li>A shadowing variable can have a different type. </li>
<li>Shadowing looks obscure at first, but is convenient for holding on to values after <code>.unwrap()</code>.</li>
<li>The following code demonstrates why the compiler can‚Äôt simply reuse memory locations when shadowing an immutable variable in a scope, even if the type does not change.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 1;
    let b = &amp;a;
    let a = a + 1;
    println!(&quot;{a} {b}&quot;);
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Traditionally, languages have fallen into two broad categories:</p>
<ul>
<li>Full control via manual memory management: C, C++, Pascal, ‚Ä¶</li>
<li>Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ‚Ä¶</li>
</ul>
<p>Rust offers a new mix:</p>
<blockquote>
<p>Full control <em>and</em> safety via compile time enforcement of correct memory
management.</p>
</blockquote>
<p>It does this with an explicit ownership concept.</p>
<p>First, let‚Äôs refresh how memory management works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stack-vs-the-heap"><a class="header" href="#the-stack-vs-the-heap">The Stack vs The Heap</a></h1>
<ul>
<li>
<p>Stack: Continuous area of memory for local variables.</p>
<ul>
<li>Values have fixed sizes known at compile time.</li>
<li>Extremely fast: just move a stack pointer.</li>
<li>Easy to manage: follows function calls.</li>
<li>Great memory locality.</li>
</ul>
</li>
<li>
<p>Heap: Storage of values outside of function calls.</p>
<ul>
<li>Values have dynamic sizes determined at runtime.</li>
<li>Slightly slower than the stack: some book-keeping needed.</li>
<li>No guarantee of memory locality.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>The stack is used to store the program and the variables of fixed size.</li>
<li>The heap is used for dynamically allocating memory.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-memory"><a class="header" href="#stack-memory">Stack Memory</a></h1>
<p>Creating a <code>String</code> puts fixed-sized data on the stack and dynamically sized
data on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}
</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="50" y="108" >len</text><text x="178" y="108" >5</text><text x="50" y="124" >capacity</text><text x="178" y="124" >5</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="508" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="308" y1="104" x2="508" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><path d="M 528,24 A 4,4 0,0,1 532,28" class="nofill"></path><line x1="532" y1="28" x2="532" y2="148" class="broken"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><path d="M 532,148 A 4,4 0,0,1 528,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>Mention that a <code>String</code> is backed by a <code>Vec</code>, so it has a capacity and length and can grow if mutable via reallocation on the heap.</li>
</ul>
<!-- * If students ask about it, you can mention that the underlying memory is heap allocated using the [System Allocator] and custom allocators can be implemented using the [Allocator API] -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-memory-management"><a class="header" href="#manual-memory-management">Manual Memory Management</a></h1>
<p>You allocate and deallocate heap memory yourself.</p>
<p>If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks.</p>
<h2 id="c-example"><a class="header" href="#c-example">C Example</a></h2>
<p>You must call <code>free</code> on every pointer you allocate with <code>malloc</code>:</p>
<pre><code class="language-c">void foo(size_t n) {
    int* int_array = (int*)malloc(n * sizeof(int));
    //
    // ... lots of code
    //
    free(int_array);
}
</code></pre>
<p>Memory is leaked if the function returns early between <code>malloc</code> and <code>free</code>: the
pointer is lost and we cannot deallocate the memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-based-memory-management"><a class="header" href="#scope-based-memory-management">Scope-Based Memory Management</a></h1>
<p>Constructors and destructors let you hook into the lifetime of an object.</p>
<p>By wrapping a pointer in an object, you can free memory when the object is
destroyed. The compiler guarantees that this happens, even if an exception is
raised.</p>
<p>This is often called <em>resource acquisition is initialization</em> (RAII) and gives
you smart pointers.</p>
<h2 id="c-example-1"><a class="header" href="#c-example-1">C++ Example</a></h2>
<pre><code class="language-c++">void say_hello(std::unique_ptr&lt;Person&gt; person) {
  std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; person-&gt;name &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>The <code>std::unique_ptr</code> object is allocated on the stack, and points to
memory allocated on the heap.</li>
<li>At the end of <code>say_hello</code>, the <code>std::unique_ptr</code> destructor will run.</li>
<li>The destructor frees the <code>Person</code> object it points to.</li>
</ul>
<p>Special move constructors are used when passing ownership to a function:</p>
<pre><code class="language-c++">std::unique_ptr&lt;Person&gt; person = find_person(&quot;Carla&quot;);
say_hello(std::move(person));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-memory-management"><a class="header" href="#automatic-memory-management">Automatic Memory Management</a></h1>
<p>An alternative to manual and scope-based memory management is automatic memory
management:</p>
<ul>
<li>The programmer never allocates or deallocates memory explicitly.</li>
<li>A garbage collector finds unused memory and deallocates it for the programmer.</li>
</ul>
<h2 id="java-example"><a class="header" href="#java-example">Java Example</a></h2>
<p>The <code>person</code> object is not deallocated after <code>sayHello</code> returns:</p>
<pre><code class="language-java">void sayHello(Person person) {
  System.out.println(&quot;Hello &quot; + person.getName());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-in-rust"><a class="header" href="#memory-management-in-rust">Memory Management in Rust</a></h1>
<p>Memory management in Rust is a mix:</p>
<ul>
<li>Safe and correct like Java, but without a garbage collector.</li>
<li>Depending on which abstraction (or combination of abstractions) you choose, can be a single unique pointer, reference counted, or atomically reference counted.</li>
<li>Scope-based like C++, but the compiler enforces full adherence.</li>
<li>A Rust user can choose the right abstraction for the situation, some even have no cost at runtime like C.</li>
</ul>
<p>It achieves this by modeling <em>ownership</em> explicitly.</p>
<details>
<ul>
<li>
<p>If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper types such as <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box</a>, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a>, <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>, or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>. These encapsulate ownership and memory allocation via various means, and prevent the potential errors in C.</p>
</li>
<li>
<p>You may be asked about destructors here, the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> trait is the Rust equivalent.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison"><a class="header" href="#comparison">Comparison</a></h1>
<p>Here is a rough comparison of the memory management techniques.</p>
<h2 id="pros-of-different-memory-management-techniques"><a class="header" href="#pros-of-different-memory-management-techniques">Pros of Different Memory Management Techniques</a></h2>
<ul>
<li>Manual like C:
<ul>
<li>No runtime overhead.</li>
</ul>
</li>
<li>Automatic like Java:
<ul>
<li>Fully automatic.</li>
<li>Safe and correct.</li>
</ul>
</li>
<li>Scope-based like C++:
<ul>
<li>Partially automatic.</li>
<li>No runtime overhead.</li>
</ul>
</li>
<li>Compiler-enforced scope-based like Rust:
<ul>
<li>Enforced by compiler.</li>
<li>No runtime overhead.</li>
<li>Safe and correct.</li>
</ul>
</li>
</ul>
<h2 id="cons-of-different-memory-management-techniques"><a class="header" href="#cons-of-different-memory-management-techniques">Cons of Different Memory Management Techniques</a></h2>
<ul>
<li>Manual like C:
<ul>
<li>Use-after-free.</li>
<li>Double-frees.</li>
<li>Memory leaks.</li>
</ul>
</li>
<li>Automatic like Java:
<ul>
<li>Garbage collection pauses.</li>
<li>Destructor delays.</li>
</ul>
</li>
<li>Scope-based like C++:
<ul>
<li>Complex, opt-in by programmer.</li>
<li>Potential for use-after-free.</li>
</ul>
</li>
<li>Compiler-enforced and scope-based like Rust:
<ul>
<li>Some upfront complexity.</li>
<li>Can reject valid programs.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>All variable bindings have a <em>scope</em> where they are valid and it is an error to
use a variable outside its scope:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}
</code></pre></pre>
<ul>
<li>At the end of the scope, the variable is <em>dropped</em> and the data is freed.</li>
<li>A destructor can run here to free up resources.</li>
<li>We say that the variable <em>owns</em> the value.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h1>
<p>An assignment will transfer ownership between variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}
</code></pre></pre>
<ul>
<li>The assignment of <code>s1</code> to <code>s2</code> transfers ownership.</li>
<li>The data was <em>moved</em> from <code>s1</code> and <code>s1</code> is no longer accessible.</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it has no ownership.</li>
<li>When <code>s2</code> goes out of scope, the string data is freed.</li>
<li>There is always <em>exactly</em> one variable binding which owns a value.</li>
</ul>
<details>
<ul>
<li>
<p>Mention that this is the opposite of the defaults in C++, which copies by value unless you use <code>std::move</code> (and the move constructor is defined!).</p>
</li>
<li>
<p>In Rust, your clones are explicit (by using <code>clone</code>).</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="moved-strings-in-rust"><a class="header" href="#moved-strings-in-rust">Moved Strings in Rust</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from(&quot;Rust&quot;);
    let s2: String = s1;
}
</code></pre></pre>
<ul>
<li>The heap data from <code>s1</code> is reused for <code>s2</code>.</li>
<li>When <code>s1</code> goes out of scope, nothing happens (it has been moved from).</li>
</ul>
<p>Before move to <code>s2</code>:</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div>
<p>After move to <code>s2</code>:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >4</text><text x="50" y="236" >capacity</text><text x="178" y="236" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >(inaccessible)</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div><div style="break-before: page; page-break-before: always;"></div><h1 id="double-frees-in-modern-c"><a class="header" href="#double-frees-in-modern-c">Double Frees in Modern C++</a></h1>
<p>Modern C++ solves this differently:</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // Duplicate the data in s1.
</code></pre>
<ul>
<li>The heap data from <code>s1</code> is duplicated and <code>s2</code> gets its own independent copy.</li>
<li>When <code>s1</code> and <code>s2</code> go out of scope, they each free their own memory.</li>
</ul>
<p>Before copy-assignment:</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>After copy-assignment:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div><div style="break-before: page; page-break-before: always;"></div><h1 id="moves-in-function-calls"><a class="header" href="#moves-in-function-calls">Moves in Function Calls</a></h1>
<p>When you pass a value to a function, the value is assigned to the function
parameter. This transfers ownership:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>With the first call to <code>say_hello</code>, <code>main</code> gives up ownership of <code>name</code>. Afterwards, <code>name</code> cannot be used anymore within <code>main</code>.</li>
<li>The heap memory allocated for <code>name</code> will be freed at the end of the <code>say_hello</code> function.</li>
<li><code>main</code> can retain ownership if it passes <code>name</code> as a reference (<code>&amp;name</code>) and if <code>say_hello</code> accepts a reference as a parameter.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: &amp;String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(&amp;name);
    say_hello(&amp;name);
}
</code></pre></pre>
<ul>
<li>Alternatively, <code>main</code> can pass a clone of <code>name</code> in the first call (<code>name.clone()</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name.clone());
    say_hello(name);
}
</code></pre></pre>
<ul>
<li>Rust makes it harder than C++ to inadvertently create copies by making move semantics the default, and by forcing programmers to make clones explicit.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-and-cloning"><a class="header" href="#copying-and-cloning">Copying and Cloning</a></h1>
<p>While move semantics are the default, certain types are copied by default:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;);
    println!(&quot;y: {y}&quot;);
}
</code></pre></pre>
<p>These types implement the <code>Copy</code> trait.</p>
<p>You can opt-in your own types to use copy semantics:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>After the assignment, both <code>p1</code> and <code>p2</code> own their own data.</li>
<li>We can also use <code>p1.clone()</code> to explicitly copy the data.</li>
</ul>
<details>
<p>Copying and cloning are not the same thing:</p>
<ul>
<li>Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.</li>
<li>Copying does not allow for custom logic (unlike copy constructors in C++).</li>
<li>Cloning is a more general operation and also allows for custom behavior by implementing the <code>Clone</code> trait.</li>
<li>Copying does not work on types that implement the <code>Drop</code> trait.</li>
</ul>
<p>In the above example, try the following:</p>
<ul>
<li>Add a <code>String</code> field to <code>struct Point</code>. It will not compile because <code>String</code> is not a <code>Copy</code> type.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32, String);

fn main() {
    let p1 = Point(3, 4, &quot;Pokemon&quot;);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>Remove <code>Copy</code> from the <code>derive</code> attribute. The compiler error is now in the <code>println!</code> for  <code>p1</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Clone, Debug)]
struct Point(i32, i32, String);

fn main() {
    let p1 = Point(3, 4, String::from(&quot;Pokemon&quot;));
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>Show that it works if you clone <code>p1</code> instead.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Clone, Debug)]
struct Point(i32, i32, String);

fn main() {
    let p1 = Point(3, 4, String::from(&quot;Pokemon&quot;));
    let p2 = p1.clone();
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<p>If students ask about <code>derive</code>, it is sufficient to say that this is a way to generate code in Rust
at compile time. In this case the default implementations of <code>Copy</code> and <code>Clone</code> traits are generated.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>Instead of transferring ownership when calling a function, you can let a
function <em>borrow</em> the value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li>The <code>add</code> function <em>borrows</em> two points and returns a new point.</li>
<li>The caller retains ownership of the inputs.</li>
</ul>
<details>
<p>Notes on stack returns:</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/">Playground</a>. In the ‚ÄúDEBUG‚Äù optimization level, the addresses should change, while they stay the same when changing to the ‚ÄúRELEASE‚Äù setting:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
</li>
<li>
<p>The Rust compiler can do return value optimization (RVO).</p>
</li>
</ul>
<p>See <a href="https://darkcoding.net/software/return-value-optimization-in-rust/">Grapham King‚Äôs ‚ÄúReturn Value Optimization in Rust‚Äù post</a></p>
<ul>
<li>In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always performs a simple and efficient <code>memcpy</code> copy.</li>
</ul>
<p>Elision means dropping, omitting, cutting. It is used for a sound that is not pronounced in a work, for example.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-and-unique-borrows"><a class="header" href="#shared-and-unique-borrows">Shared and Unique Borrows</a></h1>
<p>Rust puts constraints on the ways you can borrow values:</p>
<ul>
<li>You can have one or more <code>&amp;T</code> values at any given time, <em>or</em></li>
<li>You can have exactly one <code>&amp;mut T</code> value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>The above code does not compile because <code>a</code> is borrowed as mutable (through <code>c</code>) and as immutable (through <code>b</code>) at the same time.</li>
<li>Move the <code>println!</code> statement for <code>b</code> before the scope that introduces <code>c</code> to make the code compile.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;
    println!(&quot;b: {b}&quot;);
    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);

}
</code></pre></pre>
<ul>
<li>After that change, the compiler realizes that <code>b</code> is only ever used before the new mutable borrow of <code>a</code> through <code>c</code>. This is a feature of the borrow checker called ‚Äúnon-lexical lifetimes‚Äù.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>A borrowed value has a <em>lifetime</em>:</p>
<ul>
<li>The lifetime can be elided: <code>add(p1: &amp;Point, p2: &amp;Point) -&gt; Point</code>.</li>
<li>Lifetimes can also be explicit: <code>&amp;'a Point</code>, <code>&amp;'document str</code>.</li>
<li>Read <code>&amp;'a Point</code> as ‚Äúa borrowed <code>Point</code> which is valid for at least the
lifetime <code>a</code>‚Äù.</li>
<li>Lifetimes are always inferred by the compiler: you cannot assign a lifetime
yourself.
<ul>
<li>Lifetime annotations create constraints; the compiler verifies that there is
a valid solution.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-in-function-calls"><a class="header" href="#lifetimes-in-function-calls">Lifetimes in Function Calls</a></h1>
<p>In addition to borrowing its arguments, a function can return a borrowed value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3: &amp;Point = left_most(&amp;p1, &amp;p2);
    println!(&quot;left-most point: {:?}&quot;, p3);
}
</code></pre></pre>
<ul>
<li><code>'a</code> is a generic parameter, it is inferred by the compiler.</li>
<li>Lifetimes start with <code>'</code> and <code>'a</code> is a typical default name.</li>
<li>Read <code>&amp;'a Point</code> as ‚Äúa borrowed <code>Point</code> which is valid for at least the
lifetime <code>a</code>‚Äù.
<ul>
<li>The <em>at least</em> part is important when parameters are in different scopes.</li>
</ul>
</li>
</ul>
<details>
<p>In the above example, try the following:</p>
<ul>
<li>
<p>Move the declaration of <code>p2</code> and <code>p3</code> into a a new scope (<code>{ ... }</code>), resulting in the following code:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p3: &amp;Point;
    {
        let p2: Point = Point(20, 20);
        p3 = left_most(&amp;p1, &amp;p2);
    }
    println!(&quot;left-most point: {:?}&quot;, p3);
}
</code></pre>
<p>Note how this does not compile since <code>p3</code> outlives <code>p2</code>.</p>
</li>
<li>
<p>Reset the workspace and change the function signature to <code>fn left_most&lt;'a, 'b&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'b Point</code>. This will not compile because the relationship between the lifetimes <code>'a</code> and <code>'b</code> is unclear.</p>
</li>
<li>
<p>Another way to explain it:</p>
<ul>
<li>Two references to two values are borrowed by a function and the function returns
another reference.</li>
<li>It must have come from one of those two inputs (or from a global variable).</li>
<li>Which one is it? The compiler needs to know, so at the call site the returned reference is not used
for longer than a variable from where the reference came from.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-in-data-structures"><a class="header" href="#lifetimes-in-data-structures">Lifetimes in Data Structures</a></h1>
<p>If a data type stores borrowed data, it must be annotated with a lifetime:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>In the above example, the annotation on <code>Highlight</code> enforces that the data underlying the contained <code>&amp;str</code> lives at least as long as any instance of <code>Highlight</code> that uses that data.</li>
<li>If <code>text</code> is consumed before the end of the lifetime of <code>fox</code> (or <code>dog</code>), the borrow checker throws an error.</li>
<li>Types with borrowed data force users to hold on to the original data. This can be useful for creating lightweight views, but it generally makes them somewhat harder to use.</li>
<li>When possible, make data structures own their data directly.</li>
<li>Some structs with multiple references inside can have more than one lifetime annotation. This can be necessary if there is a need to describe lifetime relationships between the references themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-2-exercises"><a class="header" href="#course-2-exercises">Course 2: Exercises</a></h1>
<p>We will look at two things:</p>
<ul>
<li>
<p>A small book library,</p>
</li>
<li>
<p>Iterators and ownership (hard).</p>
</li>
</ul>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-afternoon.md

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="designing-a-library"><a class="header" href="#designing-a-library">Designing a Library</a></h1>
<p>We will learn much more about structs and the <code>Vec&lt;T&gt;</code> type later. For now,
you just need to know part of its API:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut vec = vec![10, 20];
    vec.push(30);
    println!(&quot;middle value: {}&quot;, vec[vec.len() / 2]);
    for item in vec.iter() {
        println!(&quot;item: {item}&quot;);
    }
}
</code></pre></pre>
<p>Use this to create a library application. Copy the code below to
<a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and update the types to make it compile:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// This makes it possible to print Book values with {}.
impl std::fmt::Display for Book {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;{} ({})&quot;, self.title, self.year)
    }
}

impl Library {
    fn new() -&gt; Library {
        unimplemented!()
    }

    //fn len(self) -&gt; usize {
    //    unimplemented!()
    //}

    //fn is_empty(self) -&gt; bool {
    //    unimplemented!()
    //}

    //fn add_book(self, book: Book) {
    //    unimplemented!()
    //}

    //fn print_books(self) {
    //    unimplemented!()
    //}

    //fn oldest_book(self) -&gt; Option&lt;&amp;Book&gt; {
    //    unimplemented!()
    //}
}

// This shows the desired behavior. Uncomment the code below and
// implement the missing methods. You will need to update the
// method signatures, including the &quot;self&quot; parameter! You may
// also need to update the variable bindings within main.
fn main() {
    let library = Library::new();

    //println!(&quot;Our library is empty: {}&quot;, library.is_empty());
    //
    //library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    //library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    //
    //library.print_books();
    //
    //match library.oldest_book() {
    //    Some(book) =&gt; println!(&quot;My oldest book is {book}&quot;),
    //    None =&gt; println!(&quot;My library is empty!&quot;),
    //}
    //
    //println!(&quot;Our library has {} books&quot;, library.len());
}
</code></pre></pre>
<!-- <details>
    
[Solution](solutions-afternoon.md#designing-a-library)

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-and-ownership"><a class="header" href="#iterators-and-ownership">Iterators and Ownership</a></h1>
<p>The ownership model of Rust affects many APIs. An example of this is the
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> and
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
traits.</p>
<h2 id="iterator"><a class="header" href="#iterator"><code>Iterator</code></a></h2>
<p>Traits are like interfaces: they describe behavior (methods) for a type. The
<code>Iterator</code> trait simply says that you can call <code>next</code> until you get <code>None</code> back:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>You use this trait like this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    println!(&quot;v[0]: {:?}&quot;, iter.next());
    println!(&quot;v[1]: {:?}&quot;, iter.next());
    println!(&quot;v[2]: {:?}&quot;, iter.next());
    println!(&quot;No more items: {:?}&quot;, iter.next());
}
</code></pre></pre>
<p>What is the type returned by the iterator? Test your answer here:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<p>Why is this type used?</p>
<h2 id="intoiterator"><a class="header" href="#intoiterator"><code>IntoIterator</code></a></h2>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an
iterator. The related trait <code>IntoIterator</code> tells you how to create the iterator:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax here means that every implementation of <code>IntoIterator</code> must
declare two types:</p>
<ul>
<li><code>Item</code>: the type we iterate over, such as <code>i8</code>,</li>
<li><code>IntoIter</code>: the <code>Iterator</code> type returned by the <code>into_iter</code> method.</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same
<code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>Like before, what  is the type returned by the iterator?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];
    let mut iter = v.into_iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h2>
<p>Now that we know both <code>Iterator</code> and <code>IntoIterator</code>, we can build <code>for</code> loops.
They call <code>into_iter()</code> on an expression and iterates over the resulting
iterator:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];

    for word in &amp;v {
        println!(&quot;word: {word}&quot;);
    }

    for word in v {
        println!(&quot;word: {word}&quot;);
    }
}
</code></pre></pre>
<p>What is the type of <code>word</code> in each loop?</p>
<p>Experiment with the code above and then consult the documentation for <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E"><code>impl IntoIterator for &amp;Vec&lt;T&gt;</code></a>
and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E"><code>impl IntoIterator for Vec&lt;T&gt;</code></a>
to check your answers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-3"><a class="header" href="#welcome-to-course-3">Welcome to course 3</a></h1>
<p>Now that we have seen a fair amount of Rust, we will continue with:</p>
<ul>
<li>
<p>Structs, enums, methods.</p>
</li>
<li>
<p>Pattern matching: destructuring enums, structs, and arrays.</p>
</li>
</ul>
<!-- * Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and
  `continue`.

* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`
  and `Arc`.

* Modules: visibility, paths, and filesystem hierarchy. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Like C and C++, Rust has support for custom structs:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}

fn main() {
    let mut peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    peter.age = 28;
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    let jackie = Person {
        name: String::from(&quot;Jackie&quot;),
        ..peter
    };
    println!(&quot;{} is {} years old&quot;, jackie.name, jackie.age);
}
</code></pre></pre>
<details>
Key Points: 
<ul>
<li>Structs work like in C or C++.
<ul>
<li>Like in C++, and unlike in C, no typedef is needed to define a type.</li>
<li>Unlike in C++, there is no inheritance between structs.</li>
</ul>
</li>
<li>Methods are defined in an <code>impl</code> block, which we will see in following slides.</li>
<li>There are different types of structs. 
<ul>
<li>Zero-sized structs <code>e.g., struct Foo;</code> `is a structure that does not require any memore. It might be used when implementing a trait on some type but don‚Äôt have any data that you want to store in the value itself. </li>
<li>The next slide will introduce Tuple structs.</li>
</ul>
</li>
<li>.. is an operator that is used for pattern binding here. It performs a ‚Äúand the rest‚Äù pattern binding.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h1>
<p>If the field names are unimportant, you can use a tuple struct:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre></pre>
<p>This is often used for single-field wrappers (called newtypes):</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct PoundOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}

</code></pre></pre>
<details>
<p>Newtypes are a great way to encode additional information about the value in a primitive type, for example:</p>
<ul>
<li>The number is measured in some units: <code>Newtons</code> in the example above.</li>
<li>The value passed some validation when it was created, so you no longer have to validate it again at every use: ‚ÄôPhoneNumber(String)<code>or</code>OddNumber(u32)`.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-shorthand-syntax"><a class="header" href="#field-shorthand-syntax">Field Shorthand Syntax</a></h1>
<p>If you already have variables with the right names, then you can create the
struct using a shorthand:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let peter = Person::new(String::from(&quot;Peter&quot;), 27);
    println!(&quot;{peter:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>name</code> and <code>age</code> are field names of the structure and variable names.</p>
<p>The <code>new</code> function could be written using <code>Self</code> as a type, as it is interchangeable with the struct type name</p>
<pre><code class="language-rust ignore">impl Person {
    fn new(name: String, age: u8) -&gt; Self {
        Self { name, age }
    }
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>The <code>enum</code> keyword allows the creation of a type which has a few
different variants:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn generate_random_number() -&gt; i32 {
    4  // Chosen by fair dice roll. Guaranteed to be random.
}

#[derive(Debug)]
enum CoinFlip {
    Heads,
    Tails,
}

fn flip_coin() -&gt; CoinFlip {
    let random_number = generate_random_number();
    if random_number % 2 == 0 {
        return CoinFlip::Heads;
    } else {
        return CoinFlip::Tails;
    }
}

fn main() {
    println!(&quot;You got: {:?}&quot;, flip_coin());
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Enumerations allow you to collect a set of values under one type</li>
<li>This page offers an enum type <code>CoinFlip</code> with two variants <code>Heads</code> and <code>Tail</code>. You might note the namespace when using variants.</li>
<li>This might be a good time to compare Structs and Enums:
<ul>
<li>In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant payloads). </li>
<li>In both, associated functions are defined within an <code>impl</code> block.</li>
<li>You could even implement the different variants of an enum with separate structs but then they wouldn‚Äôt be the same type as they would if they were all defined in an enum. </li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variant-payloads"><a class="header" href="#variant-payloads">Variant Payloads</a></h1>
<p>You can define richer enums where the variants carry data. You can then use the
<code>match</code> statement to extract the data from each variant:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum WebEvent {
    PageLoad,                 // Variant without payload
    KeyPress(char),           // Tuple struct variant
    Click { x: i64, y: i64 }, // Full struct variant
}

#[rustfmt::skip]
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad       =&gt; println!(&quot;page loaded&quot;),
        WebEvent::KeyPress(c)    =&gt; println!(&quot;pressed '{c}'&quot;),
        WebEvent::Click { x, y } =&gt; println!(&quot;clicked at x={x}, y={y}&quot;),
    }
}

fn main() {
    let load = WebEvent::PageLoad;
    let press = WebEvent::KeyPress('x');
    let click = WebEvent::Click { x: 20, y: 80 };

    inspect(load);
    inspect(press);
    inspect(click);
}
</code></pre></pre>
<details>
<ul>
<li>In the above example, accessing the <code>char</code> in <code>KeyPress</code>, or <code>x</code> and <code>y</code> in <code>Click</code> only works within a <code>match</code> statement.</li>
<li><code>match</code> inspects a hidden discriminant field in the <code>enum</code>.</li>
</ul>
<!-- * `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level `struct Click { ... }`. The inlined version cannot implement traits, for example. -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-sizes"><a class="header" href="#enum-sizes">Enum Sizes</a></h1>
<p>Rust enums are packed tightly, taking constraints due to alignment into account:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::{align_of, size_of};

macro_rules! dbg_size {
    ($t:ty) =&gt; {
        println!(&quot;{}: size {} bytes, align: {} bytes&quot;,
                 stringify!($t), size_of::&lt;$t&gt;(), align_of::&lt;$t&gt;());
    };
}

enum Foo {
    A,
    B,
}

#[repr(u32)]
enum Bar {
    A,  // 0
    B = 10000,
    C,  // 10001
}

fn main() {
    dbg_size!(Foo);
    dbg_size!(Bar);
    dbg_size!(bool);
    dbg_size!(Option&lt;bool&gt;);
    dbg_size!(&amp;i32);
    dbg_size!(Option&lt;&amp;i32&gt;);
    // dbg_size!(Option&lt;&amp;Foo&gt;);
    // dbg_size!(&amp;Foo);
}
</code></pre></pre>
<ul>
<li>See the <a href="https://doc.rust-lang.org/reference/type-layout.html">Rust Reference</a>.</li>
</ul>
<details>
<p>Key Points: </p>
<ul>
<li>Internally Rust is using a field (discriminant) to keep track of the enum variant.</li>
<li><code>Bar</code> enum demonstrates that there is a way to control the discriminant value and type. If <code>repr</code> is removed, the discriminant type takes 2 bytes, becuase 10001 fits 2 bytes.</li>
<li>As a niche optimization an enum discriminant is merged with the pointer so that <code>Option&lt;&amp;Foo&gt;</code> is the same size as <code>&amp;Foo</code>.</li>
<li><code>Option&lt;bool&gt;</code> is another example of tight packing.</li>
<li>For <a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</li>
<li>Zero-sized types allow for efficient implementation of <code>HashSet</code> using <code>HashMap</code> with <code>()</code> as the value.</li>
<li>The ty module defines how rustc represents types internally. https://rustc-dev-guide.rust-lang.org/ty.html</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-1"><a class="header" href="#methods-1">Methods</a></h1>
<p>Rust allows you to associate functions with your new types. You do this with an
<code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn say_hello(&amp;self) {
        println!(&quot;Hello, my name is {}&quot;, self.name);
    }
}

fn main() {
    let peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    peter.say_hello();
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Methods versus functions.
<ul>
<li>Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as <code>self</code>.</li>
<li>Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. By using methods we can keep all the implementation code in one predictable place.</li>
</ul>
</li>
<li>Point out the use of the keyword <code>self</code>, a method receiver. <!-- * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name could also be used. 
  * Explain that Self is a type alias for the type the `impl` block is in and can be used elsewhere in the block. -->
<ul>
<li>
<p>Explain that Self is a type alias for the type the <code>impl</code> block is in and can be used elsewhere in the block. ‚Äì&gt;</p>
</li>
<li>
<p>Note how self is used like other structs and dot notation can be used to refer to individual fields.</p>
</li>
<li>
<p>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by modifying the code and trying to run say_hello twice.</p>
</li>
</ul>
</li>
<li>We describe the distinction between method receivers next.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-receiver"><a class="header" href="#method-receiver">Method Receiver</a></h1>
<p>The <code>&amp;self</code> above indicates that the method borrows the object immutably. There
are other possible receivers for a method:</p>
<ul>
<li><code>&amp;self</code>: borrows the object from the caller using a shared and immutable
reference. The object can be used again afterwards.</li>
<li><code>&amp;mut self</code>: borrows the object from the caller using a unique and mutable
reference. The object can be used again afterwards.</li>
<li><code>self</code>: takes ownership of the object and moves it away from the caller. The
method becomes the owner of the object. The object will be dropped (deallocated)
when the method returns, unless its ownership is explicitly
transmitted.</li>
<li><code>mut self</code>: same as above, but while the method owns the object, it can
mutate it too. Complete ownership does not automatically mean mutability.</li>
<li>No receiver: this becomes a static method on the struct. Typically used to
create constructors which are called <code>new</code> by convention.</li>
</ul>
<p>Beyond variants on <code>self</code>, there are also
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a>
allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</p>
<details>
<p>Consider emphasizing on ‚Äúshared and immutable‚Äù and ‚Äúunique and mutable‚Äù. These constraints always come
together in Rust due to borrow checker rules, and <code>self</code> is no exception. It won‚Äôt be possible to
reference a struct from multiple locations and call a mutating (<code>&amp;mut self</code>) method on it.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    fn new(name: &amp;str) -&gt; Race {  // No receiver, a static method
        Race { name: String::from(name), laps: Vec::new() }
    }

    fn add_lap(&amp;mut self, lap: i32) {  // Exclusive borrowed read-write access to self
        self.laps.push(lap);
    }

    fn print_laps(&amp;self) {  // Shared and read-only borrowed access to self
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    fn finish(self) {  // Exclusive ownership of self
        let total = self.laps.iter().sum::&lt;i32&gt;();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>All four methods here use a different method receiver.
<ul>
<li>You can point out how that changes what the function can do with the variable values and if/how it can be used again in <code>main</code>.</li>
<li>You can showcase the error that appears when trying to call <code>finish</code> twice.</li>
</ul>
</li>
<li>Note, that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the <code>&amp;</code>, <code>*</code>, <code>muts</code> so that that object matches the method signature.</li>
<li>You might point out that <code>print_laps</code> is using a vector that is iterated over. We describe vectors in more detail in course 4. </li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>The <code>match</code> keyword let you match a value against one or more <em>patterns</em>. The
comparisons are done from top to bottom and the first match wins.</p>
<p>The patterns can be simple values, similarly to <code>switch</code> in C and C++:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let input = 'x';

    match input {
        'q'                   =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd' =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'             =&gt; println!(&quot;Number input&quot;),
        _                     =&gt; println!(&quot;Something else&quot;),
    }
}
</code></pre></pre>
<p>The <code>_</code> pattern is a wildcard pattern which matches any value.</p>
<details>
<p>Key Points:</p>
<ul>
<li>You might point out how some specific characters are being used when in a patten
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li><code>_</code> is a wild card</li>
</ul>
</li>
<li>It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around <code>q</code>.</li>
<li>You can demonstrate matching on a reference.</li>
<li>This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.</li>
</ul>
<p>From <a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">Rust Book</a></p>
<p>‚ÄúPatterns that will match for any possible value passed are irrefutable. An example would be x in the statement let x = 5; because x matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are refutable. An example would be Some(x) in the expression if let Some(x) = a_value because if the value in the a_value variable is None rather than Some, the Some(x) pattern will not match.‚Äù</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h1>
<p>Patterns can also be used to bind variables to parts of your values. This is how
you inspect the structure of your types. Let us start with a simple <code>enum</code> type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}
</code></pre></pre>
<p>Here we have used the arms to <em>destructure</em> the <code>Result</code> value. In the first
arm, <code>half</code> is bound to the value inside the <code>Ok</code> variant. In the second arm,
<code>msg</code> is bound to the error message.</p>
<details>
<p>Key points:</p>
<ul>
<li>The <code>if</code>/<code>else</code> expression is returning an enum that is later unpacked with a <code>match</code>.</li>
<li>You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now inexhaustive and how the compiler tries to give you hints.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Result {
    Ok(i32),
    Err(String),
    Add(i32),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 99;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
        Result::Add(a) =&gt; println!(&quot;{}&quot;,a)
    }
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h1>
<p>You can also destructure <code>structs</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, i = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>#[rustfmt::skip]</code> disables rust formatting for the following block of code</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-arrays"><a class="header" href="#destructuring-arrays">Destructuring Arrays</a></h1>
<p>You can destructure arrays, tuples, and slices by matching on their elements:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let triple = [0, -2, 3];
    println!(&quot;Tell me about {triple:?}&quot;);
    match triple {
        [0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        [1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _         =&gt; println!(&quot;All elements were ignored&quot;),
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-guards"><a class="header" href="#match-guards">Match Guards</a></h1>
<p>When matching, you can add a <em>guard</em> to a pattern. This is an arbitrary Boolean
expression which will be executed if the pattern matches:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let pair = (2, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Match guards as a separate syntax feature are important and necessary.</li>
<li>They are not the same as separate <code>if</code> expression inside of the match arm. An <code>if</code> expression inside of the branch block (after <code>=&gt;</code>) happens after the match arm is selected. Failing the <code>if</code> condition inside of that block won‚Äôt result in other arms
of the original <code>match</code> expression being considered.</li>
<li>You can use the variables defined in the pattern in your if expression.</li>
<li>The condition defined in the guard applies to every expression in a pattern with an <code>|</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let pair = (1, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) | (x, -2) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-3-exercises"><a class="header" href="#course-3-exercises">Course 3: Exercises</a></h1>
<p>We will look at implementing methods in two contexts:</p>
<ul>
<li>
<p>Simple struct which tracks health statistics.</p>
</li>
<li>
<p>Multiple structs and enums for a drawing library.</p>
</li>
</ul>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-statistics"><a class="header" href="#health-statistics">Health Statistics</a></h1>
<p>You‚Äôre working on implementing a health-monitoring system. As part of that, you
need to keep track of users‚Äô health statistics.</p>
<p>You‚Äôll start with some stubbed functions in an <code>impl</code> block as well as a <code>User</code>
struct definition. Your goal is to implement the stubbed out methods on the
<code>User</code> <code>struct</code> defined in the <code>impl</code> block.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

struct User {
    name: String,
    age: u32,
    weight: f32,
}

impl User {
    pub fn new(name: String, age: u32, weight: f32) -&gt; Self {
        unimplemented!()
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        unimplemented!()
    }

    pub fn age(&amp;self) -&gt; u32 {
        unimplemented!()
    }

    pub fn weight(&amp;self) -&gt; f32 {
        unimplemented!()
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        unimplemented!()
    }

    pub fn set_weight(&amp;mut self, new_weight: f32) {
        unimplemented!()
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_weight() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.weight(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polygon-struct"><a class="header" href="#polygon-struct">Polygon Struct</a></h1>
<p>We will create a <code>Polygon</code> struct which contain some points. Copy the code below
to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing methods to make the
tests pass:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct Point {
    // add fields
}

impl Point {
    // add methods
}

pub struct Polygon {
    // add fields
}

impl Polygon {
    // add methods
}

pub struct Circle {
    // add fields
}

impl Circle {
    // add methods
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<details>
<p>Since the method signatures are missing from the problem statements, the key part
of the exercise is to specify those correctly.</p>
<p>Other interesting parts of the exercise:</p>
<ul>
<li>Derive a <code>Copy</code> trait for some structs, as in tests the methods sometimes don‚Äôt borrow their arguments.</li>
<li>Discover that <code>Add</code> trait must be implemented for two objects to be addable via ‚Äú+‚Äù.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-4"><a class="header" href="#welcome-to-course-4">Welcome to course 4</a></h1>
<p>Now that we have seen a fair amount of Rust, we will continue with:</p>
<!-- * Structs, enums, methods.

* Pattern matching: destructuring enums, structs, and arrays. -->
<ul>
<li>
<p>Control flow constructs: <code>if</code>, <code>if let</code>, <code>while</code>, <code>while let</code>, <code>break</code>, and
<code>continue</code>.</p>
</li>
<li>
<p>The Standard Library: <code>String</code>, <code>Option</code> and <code>Result</code>, <code>Vec</code>, <code>HashMap</code>, <code>Rc</code>
and <code>Arc</code>.</p>
</li>
<li>
<p>Modules: visibility, paths, and filesystem hierarchy.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>As we have seen, <code>if</code> is an expression in Rust. It is used to conditionally
evaluate one of two blocks, but the blocks can have a value which then becomes
the value of the <code>if</code> expression. Other control flow expressions work similarly
in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let-expressions"><a class="header" href="#if-let-expressions"><code>if let</code> expressions</a></h1>
<p>If you want to match a value against a pattern, you can use <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arg = std::env::args().next();
    if let Some(value) = arg {
        println!(&quot;Program name: {value}&quot;);
    } else {
        println!(&quot;Missing name?&quot;);
    }
}
</code></pre></pre>
<p>See <a href="control-flow/../pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<ul>
<li><code>if let</code> can be more concise than <code>match</code>, e.g., when only one case is interesting. In contrast, <code>match</code> requires all branches to be covered.<!-- * For the similar use case consider demonstrating a newly stabilized [`let else`](https://github.com/rust-lang/rust/pull/93628) feature. --></li>
</ul>
<!-- * A common usage is handling `Some` values when working with `Option`. -->
<ul>
<li>Unlike <code>match</code>, <code>if let</code> does not support guard clauses for pattern matching.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-expressions"><a class="header" href="#while-expressions"><code>while</code> expressions</a></h1>
<p>The <code>while</code> keyword works very similar to other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    while x != 1 {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
    }
    println!(&quot;Final x: {x}&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-let-expressions"><a class="header" href="#while-let-expressions"><code>while let</code> expressions</a></h1>
<p>Like with <code>if</code>, there is a <code>while let</code> variant which repeatedly tests a value
against a pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
    }
}
</code></pre></pre>
<p>Here the iterator returned by <code>v.iter()</code> will return a <code>Option&lt;i32&gt;</code> on every
call to <code>next()</code>. It returns <code>Some(x)</code> until it is done, after which it will
return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<p>See <a href="control-flow/../pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<ul>
<li>Point out that the <code>while let</code> loop will keep going as long as the value matches the pattern.</li>
<li>You could rewrite the <code>while let</code> loop as an infinite loop with an if statement that breaks when there is no value to unwrap for <code>iter.next()</code>. The <code>while let</code> provides syntactic sugar for the above scenario. </li>
</ul>
<!-- ```rust,editable
fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    loop { if let Some(x) = iter.next() {
        println!("x: {x}");
        } else {
            break;
        }
    }
}
``` -->
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-expressions"><a class="header" href="#for-expressions"><code>for</code> expressions</a></h1>
<p>The <code>for</code> expression is closely related to the <code>while let</code> expression. It will
automatically call <code>into_iter()</code> on the expression and then iterate over it:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];

    for x in v {
        println!(&quot;x: {x}&quot;);
    }
    
    for i in (0..10).step_by(2) {
        println!(&quot;i: {i}&quot;);
    }
}
</code></pre></pre>
<p>You can use <code>break</code> and <code>continue</code> here as usual.</p>
<details>
<ul>
<li>Index iteration is not a special syntax in Rust for just that case.</li>
<li><code>(0..10)</code> is a range that implements an <code>Iterator</code> trait. </li>
<li><code>step_by</code> is a method that returns another <code>Iterator</code> that skips every other element. </li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-expressions"><a class="header" href="#loop-expressions"><code>loop</code> expressions</a></h1>
<p>Finally, there is a <code>loop</code> keyword which creates an endless loop. Here you must
either <code>break</code> or <code>return</code> to stop the loop:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    loop {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
        if x == 1 {
            break;
        }
    }
    println!(&quot;Final x: {x}&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h1>
<p>The <code>match</code> keyword is used to match a value against one or more patterns. In
that sense, it works like a series of <code>if let</code> expressions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    match std::env::args().next().as_deref() {
        Some(&quot;cat&quot;) =&gt; println!(&quot;Will do cat things&quot;),
        Some(&quot;ls&quot;)  =&gt; println!(&quot;Will ls some files&quot;),
        Some(&quot;mv&quot;)  =&gt; println!(&quot;Let's move some files&quot;),
        Some(&quot;rm&quot;)  =&gt; println!(&quot;Uh, dangerous!&quot;),
        None        =&gt; println!(&quot;Hmm, no program name?&quot;),
        _           =&gt; println!(&quot;Unknown program name!&quot;),
    }
}
</code></pre></pre>
<p>Like <code>if let</code>, each match arm must have the same type. The type is the last
expression of the block, if any. In the example above, the type is <code>()</code>.</p>
<p>See <a href="control-flow/../pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h1>
<p>If you want to exit a loop early, use <code>break</code>, if you want to immediately start
the next iteration use <code>continue</code>. Both <code>continue</code> and <code>break</code> can optionally
take a label argument which is used to break out of nested loops:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();
    'outer: while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
        let mut i = 0;
        while i &lt; x {
            println!(&quot;x: {x}, i: {i}&quot;);
            i += 1;
            if i == 3 {
                break 'outer;
            }
        }
    }
}
</code></pre></pre>
<p>In this case we break the outer loop after 3 iterations of the inner loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Rust comes with a standard library which helps establish a set of common types
used by Rust library and programs. This way, two libraries can work together
smoothly because they both use the same <code>String</code> type.</p>
<p>The common vocabulary types include:</p>
<ul>
<li>
<p><a href="std/option-result.html"><code>Option</code> and <code>Result</code></a> types: used for optional values
and <a href="error-handling.html">error handling</a>.</p>
</li>
<li>
<p><a href="std/string.html"><code>String</code></a>: the default string type used for owned data.</p>
</li>
<li>
<p><a href="std/vec.html"><code>Vec</code></a>: a standard extensible vector.</p>
</li>
<li>
<p><a href="std/hashmap.html"><code>HashMap</code></a>: a hash map type with a configurable hashing
algorithm.</p>
</li>
<li>
<p><a href="std/box.html"><code>Box</code></a>: an owned pointer for heap-allocated data.</p>
</li>
<li>
<p><a href="std/rc.html"><code>Rc</code></a>: a shared reference-counted pointer for heap-allocated data.</p>
</li>
</ul>
<details>
<ul>
<li>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code> and <code>std</code>. </li>
<li><code>core</code> includes the most basic types and functions that don‚Äôt depend on <code>libc</code>, allocator or
even the presence of an operating system. </li>
<li><code>alloc</code> includes types which require a global heap allocator, such as <code>Vec</code>, <code>Box</code> and <code>Arc</code>.</li>
<li>Embedded Rust applications often only use <code>core</code>, and sometimes <code>alloc</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-and-result"><a class="header" href="#option-and-result"><code>Option</code> and <code>Result</code></a></h1>
<p>The types represent optional data:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let numbers = vec![10, 20, 30];
    let first: Option&lt;&amp;i8&gt; = numbers.first();
    println!(&quot;first: {first:?}&quot;);

    let idx: Result&lt;usize, usize&gt; = numbers.binary_search(&amp;10);
    println!(&quot;idx: {idx:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Option</code> and <code>Result</code> are widely used not just in the standard library.</li>
<li><code>Option&lt;&amp;T&gt;</code> has zero space overhead compared to <code>&amp;T</code>.</li>
<li><code>Result</code> is the standard type to implement error handling as we will see in a later course.</li>
<li><code>binary_search</code> returns <code>Result&lt;usize, usize&gt;</code>.
<ul>
<li>If found, <code>Result::Ok</code> holds the index where the element is found.</li>
<li>Otherwise, <code>Result::Err</code> contains the index where such an element should be inserted.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is the standard heap-allocated growable UTF-8 string buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;üá®üá≠&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(),
             s3.chars().count());
}
</code></pre></pre>
<p><code>String</code> implements <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>, which means that you can call all
<code>str</code> methods on a <code>String</code>.</p>
<details>
<ul>
<li><code>len</code> returns the size of the <code>String</code> in bytes, not its length in characters.</li>
<li><code>chars</code> returns an iterator over the actual characters.</li>
<li><code>String</code> implements <code>Deref&lt;Target = str&gt;</code> which transparently gives it access to <code>str</code>‚Äôs methods.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> is the standard resizable heap-allocated buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());
}
</code></pre></pre>
<p><code>Vec</code> implements <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>, which means that you can call slice
methods on a <code>Vec</code>.</p>
<details>
<ul>
<li>
<p><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored
on the heap. This means the amount of data doesn‚Äôt need to be  known at compile time. It can grow
or shrink at runtime.</p>
</li>
<li>
<p>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don‚Äôt have to specify <code>T</code> explicitly. As always
with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</p>
</li>
<li>
<p><code>vec![...]</code> is a canonical macro to use instead of <code>Vec::new()</code> and it supports adding initial
elements to the vector. </p>
</li>
<li>
<p>To index the vector you use <code>[</code> <code>]</code>, but they will panic if out of bounds. Alternatively, using
<code>get</code> will return an <code>Option</code>. The <code>pop</code> function will remove the last element.</p>
<p><code>println!(&quot;v2: len = {}, capacity = {}, {:?}&quot;, v2.len(), v2.capacity(), v2.get(0));</code>
<code>println!(&quot;{:?}&quot;,v2.pop());</code></p>
</li>
<li>
<p>Show iterating over a vector and mutating the value:
<code>for e in &amp;mut v { *e += 50; }</code></p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p>Standard hash map with protection against HashDoS attacks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;.to_string(), 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;.to_string(), 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;.to_string(), 303);

    if !page_counts.contains_key(&quot;Les Mis√©rables&quot;) {
        println!(&quot;We've know about {} books, but not Les Mis√©rables.&quot;,
                 page_counts.len());
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;)
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box"><code>Box</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> is an owned pointer to data on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> implements <code>Deref&lt;Target = T&gt;</code>, which means that you can <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">call methods
from <code>T</code> directly on a <code>Box&lt;T&gt;</code></a>.</p>
<details>
<ul>
<li><code>Box</code> is like <code>std::unique_ptr</code> in C++.</li>
<li>In the above example, you can even leave out the <code>*</code> in the <code>println!</code> statement thanks to <code>Deref</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-with-recursive-data-structures"><a class="header" href="#box-with-recursive-data-structures">Box with Recursive Data Structures</a></h1>
<p>Recursive data types or data types with dynamic sizes need to use a <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >Tag</text><text x="122" y="92" >Cons</text><text x="314" y="92" >Tag</text><text x="386" y="92" >Cons</text><text x="498" y="92" >Tag</text><text x="570" y="92" >Nil</text><text x="50" y="108" >0</text><text x="122" y="108" >1</text><text x="314" y="108" >0</text><text x="386" y="108" >2</text><line x1="504" y1="96" x2="496" y2="112" class="solid"></line><line x1="512" y1="96" x2="496" y2="128" class="solid"></line><line x1="520" y1="96" x2="504" y2="128" class="solid"></line><line x1="528" y1="96" x2="512" y2="128" class="solid"></line><line x1="536" y1="96" x2="520" y2="128" class="solid"></line><line x1="544" y1="96" x2="528" y2="128" class="solid"></line><line x1="544" y1="112" x2="536" y2="128" class="solid"></line><line x1="576" y1="96" x2="568" y2="112" class="solid"></line><line x1="584" y1="96" x2="568" y2="128" class="solid"></line><line x1="592" y1="96" x2="576" y2="128" class="solid"></line><line x1="600" y1="96" x2="584" y2="128" class="solid"></line><line x1="600" y1="112" x2="592" y2="128" class="solid"></line><text x="50" y="124" >1</text><circle cx="124" cy="120" r="3" class="nofill"></circle><text x="314" y="124" >1</text><circle cx="388" cy="120" r="3" class="nofill"></circle><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="280" y1="184" x2="288" y2="184" class="solid"></line><line x1="296" y1="184" x2="304" y2="184" class="solid"></line><line x1="312" y1="184" x2="320" y2="184" class="solid"></line><line x1="328" y1="184" x2="336" y2="184" class="solid"></line><line x1="344" y1="184" x2="352" y2="184" class="solid"></line><line x1="360" y1="184" x2="368" y2="184" class="solid"></line><line x1="376" y1="184" x2="384" y2="184" class="solid"></line><line x1="392" y1="184" x2="400" y2="184" class="solid"></line><line x1="408" y1="184" x2="416" y2="184" class="solid"></line><line x1="424" y1="184" x2="432" y2="184" class="solid"></line><line x1="440" y1="184" x2="448" y2="184" class="solid"></line><line x1="456" y1="184" x2="464" y2="184" class="solid"></line><line x1="472" y1="184" x2="480" y2="184" class="solid"></line><line x1="488" y1="184" x2="496" y2="184" class="solid"></line><line x1="504" y1="184" x2="512" y2="184" class="solid"></line><line x1="520" y1="184" x2="528" y2="184" class="solid"></line><line x1="536" y1="184" x2="544" y2="184" class="solid"></line><line x1="552" y1="184" x2="560" y2="184" class="solid"></line><line x1="568" y1="184" x2="576" y2="184" class="solid"></line><line x1="584" y1="184" x2="592" y2="184" class="solid"></line><line x1="600" y1="184" x2="608" y2="184" class="solid"></line><line x1="616" y1="184" x2="624" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="180" class="broken"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><path d="M 212,180 A 4,4 0,0,1 208,184" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="180" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,180 A 4,4 0,0,0 264,184" class="nofill"></path><line x1="264" y1="184" x2="272" y2="184" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="108" y1="72" x2="108" y2="136" class="solid"></line><line x1="172" y1="72" x2="172" y2="136" class="solid"></line><line x1="36" y1="136" x2="172" y2="136" class="solid"></line></g><g><line x1="300" y1="72" x2="444" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="136" class="solid"></line><line x1="372" y1="72" x2="372" y2="136" class="solid"></line><line x1="444" y1="72" x2="444" y2="136" class="solid"></line><line x1="300" y1="136" x2="444" y2="136" class="solid"></line></g><g><line x1="484" y1="72" x2="612" y2="72" class="solid"></line><line x1="484" y1="72" x2="484" y2="136" class="solid"></line><line x1="556" y1="72" x2="556" y2="136" class="solid"></line><line x1="612" y1="72" x2="612" y2="136" class="solid"></line><line x1="484" y1="136" x2="612" y2="136" class="solid"></line></g><g><path d="M 280,88 A 4,4 0,0,0 276,92" class="nofill"></path><line x1="276" y1="92" x2="276" y2="116" class="solid"></line><line x1="280" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon><line x1="128" y1="120" x2="272" y2="120" class="solid"></line><path d="M 276,116 A 4,4 0,0,1 272,120" class="nofill"></path></g><g><path d="M 464,88 A 4,4 0,0,0 460,92" class="nofill"></path><line x1="460" y1="92" x2="460" y2="116" class="solid"></line><line x1="464" y1="88" x2="472" y2="88" class="solid"></line><polygon points="472,84 480,88 472,92" class="filled"></polygon><line x1="392" y1="120" x2="456" y2="120" class="solid"></line><path d="M 460,116 A 4,4 0,0,1 456,120" class="nofill"></path></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="180" class="broken"></line><line x1="632" y1="184" x2="640" y2="184" class="solid"></line><path d="M 644,180 A 4,4 0,0,1 640,184" class="nofill"></path></g></svg></div>
<details>
<p>If the <code>Box</code> was not used here and we attempted to embed a <code>List</code> directly into the <code>List</code>,
the compiler would not compute a fixed size of the struct in memory, it would look infinite.</p>
<p><code>Box</code> solves this problem as it has the same size as a regular pointer and just points at the next
element of the <code>List</code> in the heap.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="niche-optimization"><a class="header" href="#niche-optimization">Niche Optimization</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<p>A <code>Box</code> cannot be empty, so the pointer is always valid and non-<code>null</code>. This
allows the compiler to optimize the memory layout:</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >0</text><text x="122" y="92" >1</text><text x="314" y="92" >0</text><text x="394" y="92" >2</text><line x1="504" y1="80" x2="496" y2="96" class="solid"></line><line x1="512" y1="80" x2="504" y2="96" class="solid"></line><line x1="520" y1="80" x2="512" y2="96" class="solid"></line><line x1="528" y1="80" x2="520" y2="96" class="solid"></line><line x1="536" y1="80" x2="528" y2="96" class="solid"></line><line x1="544" y1="80" x2="536" y2="96" class="solid"></line><line x1="576" y1="80" x2="568" y2="96" class="solid"></line><line x1="584" y1="80" x2="576" y2="96" class="solid"></line><line x1="592" y1="80" x2="584" y2="96" class="solid"></line><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><circle cx="124" cy="104" r="3" class="nofill"></circle><circle cx="396" cy="104" r="3" class="nofill"></circle><text x="570" y="108" >null</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="280" y1="168" x2="288" y2="168" class="solid"></line><line x1="296" y1="168" x2="304" y2="168" class="solid"></line><line x1="312" y1="168" x2="320" y2="168" class="solid"></line><line x1="328" y1="168" x2="336" y2="168" class="solid"></line><line x1="344" y1="168" x2="352" y2="168" class="solid"></line><line x1="360" y1="168" x2="368" y2="168" class="solid"></line><line x1="376" y1="168" x2="384" y2="168" class="solid"></line><line x1="392" y1="168" x2="400" y2="168" class="solid"></line><line x1="408" y1="168" x2="416" y2="168" class="solid"></line><line x1="424" y1="168" x2="432" y2="168" class="solid"></line><line x1="440" y1="168" x2="448" y2="168" class="solid"></line><line x1="456" y1="168" x2="464" y2="168" class="solid"></line><line x1="472" y1="168" x2="480" y2="168" class="solid"></line><line x1="488" y1="168" x2="496" y2="168" class="solid"></line><line x1="504" y1="168" x2="512" y2="168" class="solid"></line><line x1="520" y1="168" x2="528" y2="168" class="solid"></line><line x1="536" y1="168" x2="544" y2="168" class="solid"></line><line x1="552" y1="168" x2="560" y2="168" class="solid"></line><line x1="568" y1="168" x2="576" y2="168" class="solid"></line><line x1="584" y1="168" x2="592" y2="168" class="solid"></line><line x1="600" y1="168" x2="608" y2="168" class="solid"></line><line x1="616" y1="168" x2="624" y2="168" class="solid"></line><text x="50" y="108" >1/Tag</text><text x="314" y="108" >1/Tag</text><text x="498" y="108" >1/Tag</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="164" class="broken"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><path d="M 212,164 A 4,4 0,0,1 208,168" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="164" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,164 A 4,4 0,0,0 264,168" class="nofill"></path><line x1="264" y1="168" x2="272" y2="168" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="120" class="solid"></line><line x1="108" y1="72" x2="108" y2="120" class="solid"></line><line x1="172" y1="72" x2="172" y2="120" class="solid"></line><line x1="36" y1="120" x2="172" y2="120" class="solid"></line></g><g><line x1="300" y1="72" x2="444" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="120" class="solid"></line><line x1="372" y1="72" x2="372" y2="120" class="solid"></line><line x1="444" y1="72" x2="444" y2="120" class="solid"></line><line x1="300" y1="120" x2="444" y2="120" class="solid"></line></g><g><line x1="484" y1="72" x2="612" y2="72" class="solid"></line><line x1="484" y1="72" x2="484" y2="120" class="solid"></line><line x1="556" y1="72" x2="556" y2="120" class="solid"></line><line x1="612" y1="72" x2="612" y2="120" class="solid"></line><line x1="484" y1="120" x2="612" y2="120" class="solid"></line></g><g><path d="M 280,88 A 4,4 0,0,0 276,92" class="nofill"></path><line x1="276" y1="92" x2="276" y2="100" class="solid"></line><line x1="280" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon><line x1="128" y1="104" x2="272" y2="104" class="solid"></line><path d="M 276,100 A 4,4 0,0,1 272,104" class="nofill"></path></g><g><path d="M 464,88 A 4,4 0,0,0 460,92" class="nofill"></path><line x1="460" y1="92" x2="460" y2="100" class="solid"></line><line x1="464" y1="88" x2="472" y2="88" class="solid"></line><polygon points="472,84 480,88 472,92" class="filled"></polygon><line x1="400" y1="104" x2="456" y2="104" class="solid"></line><path d="M 460,100 A 4,4 0,0,1 456,104" class="nofill"></path></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="164" class="broken"></line><line x1="632" y1="168" x2="640" y2="168" class="solid"></line><path d="M 644,164 A 4,4 0,0,1 640,168" class="nofill"></path></g></svg></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> is a reference-counted shared pointer. Use this when you need to refer
to the same data from multiple places:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::rc::Rc;

fn main() {
    let mut a = Rc::new(10);
    let mut b = a.clone();

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<p>Shared references in Rust disallow mutation by default. 
If you need to mutate the data inside an <code>Rc</code>, you will need to wrap the data in
a type such as <a href="https://doc.rust-lang.org/std/cell/index.html"><code>Cell</code> or <code>RefCell</code></a>, in single-threaded cases. See <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> if you are in a multi-threaded
context. Arc stands for ‚ÄúAtomically Reference counted‚Äù. If you need to mutate through Arc use <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>, or one of the <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>Atomic</code></a> types.</p>
<details>
<ul>
<li>Like C++‚Äôs <code>std::shared_ptr</code>.</li>
<li><code>clone</code> is cheap: creates a pointer to the same allocation and increases the reference count.</li>
<li><code>make_mut</code> actually clones the inner value if necessary (‚Äúclone-on-write‚Äù) and returns a mutable reference.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>We have seen how <code>impl</code> blocks let us namespace functions to a type.</p>
<p>Similarly, <code>mod</code> lets us namespace types and functions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Modules are a privacy boundary:</p>
<ul>
<li>Module items are private by default (hides implementation details).</li>
<li>Parent and sibling items are always visible.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paths"><a class="header" href="#paths">Paths</a></h1>
<p>Paths are resolved as follows:</p>
<ol>
<li>
<p>As a relative path:</p>
<ul>
<li><code>foo</code> or <code>self::foo</code> refers to <code>foo</code> in the current module,</li>
<li><code>super::foo</code> refers to <code>foo</code> in the parent module.</li>
</ul>
</li>
<li>
<p>As an absolute path:</p>
<ul>
<li><code>crate::foo</code> refers to <code>foo</code> in the root of the current crate,</li>
<li><code>bar::foo</code> refers to <code>foo</code> in the <code>bar</code> crate.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystem-hierarchy"><a class="header" href="#filesystem-hierarchy">Filesystem Hierarchy</a></h1>
<p>The module content can be omitted:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">mod garden;
</code></pre></pre>
<p>The <code>garden</code> module content is found at:</p>
<ul>
<li><code>src/garden.rs</code> (modern Rust 2018 style)</li>
<li><code>src/garden/mod.rs</code> (older Rust 2015 style)</li>
</ul>
<p>Similarly, a <code>garden::vegetables</code> module can be found at:</p>
<ul>
<li><code>src/garden/vegetables.rs</code> (modern Rust 2018 style)</li>
<li><code>src/garden/vegetables/mod.rs</code> (older Rust 2015 style)</li>
</ul>
<p>The <code>crate</code> root is in:</p>
<ul>
<li><code>src/lib.rs</code> (for a library crate)</li>
<li><code>src/main.rs</code> (for a binary crate)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-4-exercises"><a class="header" href="#course-4-exercises">Course 4: Exercises</a></h1>
<p>In course 4, the exercices will focus on strings and iterators.</p>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-afternoon.md

</details>
 --><div style="break-before: page; page-break-before: always;"></div><h1 id="luhn-algorithm"><a class="header" href="#luhn-algorithm">Luhn Algorithm</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a> is used to
validate credit card numbers. The algorithm takes a string as input and does the
following to validate the credit card number:</p>
<ul>
<li>
<p>Ignore all spaces. Reject number with less than two digits.</p>
</li>
<li>
<p>Moving from right to left, double every second digit: for the number <code>1234</code>,
we double <code>3</code> and <code>1</code>.</p>
</li>
<li>
<p>After doubling a digit, sum the digits. So doubling <code>7</code> becomes <code>14</code> which
becomes <code>5</code>.</p>
</li>
<li>
<p>Sum all the undoubled and doubled digits.</p>
</li>
<li>
<p>The credit card number is valid if the sum ends with <code>0</code>.</p>
</li>
</ul>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the
function:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn luhn(cc_number: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings-and-iterators"><a class="header" href="#strings-and-iterators">Strings and Iterators</a></h1>
<p>In this exercise, you are implementing a routing component of a web server. The
server is configured with a number of <em>path prefixes</em> which are matched against
<em>request paths</em>. The path prefixes can contain a wildcard character which
matches a full segment. See the unit tests below.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests
pass. Try avoiding allocating a <code>Vec</code> for your intermediate results:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-5"><a class="header" href="#welcome-to-course-5">Welcome to course 5</a></h1>
<p>In this course, we will cover some more advanced topics of Rust:</p>
<ul>
<li>
<p>Traits: deriving traits, default methods, and important standard library
traits.</p>
</li>
<li>
<p>Generics: generic data types, generic methods, monomorphization, and trait
objects.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Rust lets you abstract over types with traits. They‚Äôre similar to interfaces:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Greet {
    fn say_hello(&amp;self);
}

struct Dog {
    name: String,
}

struct Cat;  // No name, cats won't respond to it anyway.

impl Greet for Dog {
    fn say_hello(&amp;self) {
        println!(&quot;Wuf, my name is {}!&quot;, self.name);
    }
}

impl Greet for Cat {
    fn say_hello(&amp;self) {
        println!(&quot;Miau!&quot;);
    }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Greet&gt;&gt; = vec![
        Box::new(Dog { name: String::from(&quot;Fido&quot;) }),
        Box::new(Cat),
    ];
    for pet in pets {
        pet.say_hello();
    }
}
</code></pre></pre>
<details>
<ul>
<li>Traits may specify pre-implemented (default) methods and methods that users are required to implement themselves. Methods with default implementations can rely on required methods.</li>
<li>Types that implement a given trait may be of different sizes. This makes it impossible to have things like <code>Vec&lt;Greet&gt;</code> in the example above.</li>
<li><code>dyn Greet</code> is a way to tell the compiler about a dynamically sized type that implements <code>Greet</code>. The compiler does not know the concrete type that is being passed.</li>
<li>In the example, <code>pets</code> holds Fat Pointers to objects that implement <code>Greet</code>. The Fat Pointer consists of two components, a pointer to the actual object and a pointer to the virtual method table for the <code>Greet</code> implementation of that particular object.</li>
</ul>
<p>From <a href="https://doc.rust-lang.org/std/keyword.dyn.html">rust-lang</a>, ‚Äúa dyn Trait reference contains two pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable). At run-time, when a method needs to be called on the dyn Trait, the vtable is consulted to get the function pointer and then that function pointer is called.‚Äù</p>
<p>Compare these outputs in the above example:</p>
<pre><code class="language-rust ignore">    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Greet&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Greet&gt;&gt;());
</code></pre>
<p>This gives the output:</p>
<pre><code class="language-rust ignore">24 0
8 8
16
16
</code></pre>
</details>
<!-- p442 in the Rust programming language -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-traits"><a class="header" href="#deriving-traits">Deriving Traits</a></h1>
<p>You can let the compiler derive a number of traits:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Clone, PartialEq, Eq, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default();
    let p2 = p1.clone();
    println!(&quot;Is {:?}\nequal to {:?}?\nThe answer is {}!&quot;, &amp;p1, &amp;p2,
             if p1 == p2 { &quot;yes&quot; } else { &quot;no&quot; });
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-methods"><a class="header" href="#default-methods">Default Methods</a></h1>
<p>Traits can implement behavior in terms of other trait methods:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Equals {
    fn equal(&amp;self, other: &amp;Self) -&gt; bool;
    fn not_equal(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equal(other)
    }
}

#[derive(Debug)]
struct Centimeter(i16);

impl Equals for Centimeter {
    fn equal(&amp;self, other: &amp;Centimeter) -&gt; bool {
        self.0 == other.0
    }
}

fn main() {
    let a = Centimeter(10);
    let b = Centimeter(20);
    println!(&quot;{a:?} equals {b:?}: {}&quot;, a.equal(&amp;b));
    println!(&quot;{a:?} not_equals {b:?}: {}&quot;, a.not_equal(&amp;b));
}
</code></pre></pre>
<details>
<p>Centimeters reuses the behavior of <code>not_equal</code> from the Equals trait. It overwrites <code>equal</code>, however.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-traits"><a class="header" href="#important-traits">Important Traits</a></h1>
<p>We will now look at some of the most common traits of the Rust standard library:</p>
<ul>
<li><code>Iterator</code> and <code>IntoIterator</code> used in <code>for</code> loops,</li>
<li><code>From</code> and <code>Into</code> used to convert values,</li>
<li><code>Read</code> and <code>Write</code> used for IO,</li>
<li><code>Add</code>, <code>Mul</code>, ‚Ä¶ used for operator overloading, and</li>
<li><code>Drop</code> used for defining destructors.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>You can implement the <code>Iterator</code> trait on your own types:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>IntoIterator</code> is the trait that makes for loops work. It is implemented by collection types such as
<code>Vec&lt;T&gt;</code> and references to them such as <code>&amp;Vec&lt;T&gt;</code> and <code>&amp;[T]</code>. Ranges also implement it. <code>&amp;[T]</code> is the shared slice type.</p>
</li>
<li>
<p>The <code>Iterator</code> trait implements many common functional programming operations over collections 
(e.g. <code>map</code>, <code>filter</code>, <code>reduce</code>, etc). This is the trait where you can find all the documentation
about them. In Rust these functions should produce the code as efficient as equivalent imperative
implementations.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromiterator"><a class="header" href="#fromiterator">FromIterator</a></h1>
<p><code>FromIterator</code> lets you build a collection from an <code>Iterator</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes
        .into_iter()
        .map(|prime| prime * prime)
        .collect::&lt;Vec&lt;_&gt;&gt;();
}
</code></pre></pre>
<details>
<p><code>Iterator</code> implements
<code>fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator&lt;Self::Item&gt;, Self: Sized</code>
<code>collect</code> enables to convert an interator into a collection. Here it enables to reconstruct a vector.</p>
<p>There are also implementations which let you do cool things like convert an
<code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> into a <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>.</p>
<p>Add this line to print the computed squares:
<code>println!(&quot;{:?}&quot;, prime_squares)</code></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>Types implement <code>From</code> and <code>Into</code> to facilitate type conversions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<p><code>Into</code> is automatically implemented when <code>From</code> is implemented:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>That‚Äôs why it is common to only implement <code>From</code>, as your type will get <code>Into</code> implementation too.</li>
<li>When declaring a function argument input type like ‚Äúanything that can be converted into a <code>String</code>‚Äù, the rule is opposite, you should use <code>Into</code>.
Your function will accept types that implement <code>From</code> and those that <em>only</em> implement <code>Into</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-and-write"><a class="header" href="#read-and-write"><code>Read</code> and <code>Write</code></a></h1>
<p>Using <code>Read</code> and <code>BufRead</code>, you can abstract over <code>u8</code> sources:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}
</code></pre></pre>
<p>Similarly, <code>Write</code> lets you abstract over <code>u8</code> sinks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {:?}&quot;, buffer);
    Ok(())
}
</code></pre></pre>
<details>
<pre><code>`std::env::current_exe()` Returns the full filesystem path of the current running executable.
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-mul-"><a class="header" href="#add-mul-"><code>Add</code>, <code>Mul</code>, ‚Ä¶</a></h1>
<p>Operator overloading is implemented via traits in <code>std::ops</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Copy, Clone)]
struct Point { x: i32, y: i32 }

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {x: self.x + other.x, y: self.y + other.y}
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{:?} + {:?} = {:?}&quot;, p1, p2, p1 + p2);
}
</code></pre></pre>
<details>
<p>Discussion points:</p>
<ul>
<li>You could implement <code>Add</code> for <code>&amp;Point</code>. In which situations is that useful? 
<ul>
<li>Answer: <code>Add:add</code> consumes <code>self</code>. If type <code>T</code> for which you are
overloading the operator is not <code>Copy</code>, you should consider overloading
the operator for <code>&amp;T</code> as well. This avoids unnecessary cloning on the
call site.</li>
</ul>
</li>
<li>Why is <code>Output</code> an associated type? Could it be made a type parameter?
<ul>
<li>Short answer: Type parameters are controlled by the caller, but
associated types (like <code>Output</code>) are controlled by the implementor of a
trait.</li>
</ul>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="the-drop-trait"><a class="header" href="#the-drop-trait">The <code>Drop</code> Trait</a></h1>
<p>Values which implement <code>Drop</code> can specify code to run when they go out of scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}
</code></pre></pre>
<!-- <details>

Discussion points:

* Why does not `Drop::drop` take `self`?
    * Short-answer: If it did, `std::mem::drop` would be called at the end of
        the block, resulting in another call to `Drop::drop`, and a stack
        overflow!
* Try replacing `drop(a)` with `a.drop()`.

</details> --><div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Rust support generics, which lets you abstract an algorithm (such as sorting)
over the types used in the algorithm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>You can use generics to abstract over the concrete field type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h1>
<p>You can declare a generic type on your <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt;(T, T);

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.0  // + 10
    }

    // fn set_x(&amp;mut self, x: T)
}

fn main() {
    let p = Point(5, 10);
    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<details>
<ul>
<li><em>Q:</em> Why <code>T</code> is specified twice in <code>impl&lt;T&gt; Point&lt;T&gt; {}</code>? Isn‚Äôt that redundant?
<ul>
<li>This is because it is a generic implementation section for generic type. They are independently generic.</li>
<li>It means these methods are defined for any <code>T</code>.</li>
<li>It is possible to write <code>impl Point&lt;u32&gt; { .. }</code>. 
<ul>
<li><code>Point</code> is still generic and you can use <code>Point&lt;f64&gt;</code>, but methods in this block will only be available for <code>Point&lt;u32&gt;</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h1>
<p>When working with generics, you often want to limit the types. You can do this
with <code>T: Trait</code> or <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// struct NotClonable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);
}
</code></pre></pre>
<p>Here traits are used as bounds to stipulate what functionality a type implements. For example, above, T must implement Clone.</p>
<details>
<p>Show a <code>where</code> clause, students will encounter it when reading code.</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}
</code></pre>
<ul>
<li>It declutters the function signature if you have many parameters.</li>
<li>It has additional features making it more powerful.
<ul>
<li>If someone asks, the extra feature is that the type on the left of ‚Äú:‚Äù can be arbitrary, like <code>Option&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p>Similar to trait bounds, an <code>impl Trait</code> syntax can be used in function
arguments and return values:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn get_x(name: impl Display) -&gt; impl Display {
    format!(&quot;Hello {name}&quot;)
}

fn main() {
    let x = get_x(&quot;foo&quot;);
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<ul>
<li><code>impl Trait</code> cannot be used with the <code>::&lt;&gt;</code> turbo fish syntax.</li>
<li><code>impl Trait</code> allows you to work with types which you cannot name.</li>
</ul>
<details>
<p>The meaning of <code>impl Trait</code> is a bit different in the different positions.</p>
<ul>
<li>For a parameter, <code>impl Trait</code> is like an anonymous generic parameter with a trait bound.</li>
<li>For a return type, it means that the return type is some concrete type that implements the trait,
without naming the type. This can be useful when you don‚Äôt want to expose the concrete type in a
public API.</li>
</ul>
<p>This example is great, because it uses <code>impl Display</code> twice. It helps to explain that
nothing here enforces that it is <em>the same</em> <code>impl Display</code> type. If we used a single 
<code>T: Display</code>, it would enforce the constraint that input <code>T</code> and return <code>T</code> type are the same type.
It would not work for this particular function, as the type we expect as input is likely not
what <code>format!</code> returns. If we wanted to do the same via <code>: Display</code> syntax, we‚Äôd need two
independent generic parameters.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures or lambda expressions have types which cannot be named. However, they
implement special <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and
<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> traits:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn apply_with_log(func: impl FnOnce(i32) -&gt; i32, input: i32) -&gt; i32 {
    println!(&quot;Calling function on {input}&quot;);
    func(input)
}

fn main() {
    let add_3 = |x| x + 3;
    let mul_5 = |x| x * 5;

    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 10));
    println!(&quot;mul_5: {}&quot;, apply_with_log(mul_5, 20));
}
</code></pre></pre>
<details>
<p>If you have an <code>FnOnce</code>, you may only call it once. It might consume captured values.</p>
<p>An <code>FnMut</code> might mutate captured values, so you can call it multiple times but not concurrently.</p>
<p>An <code>Fn</code> neither consumes nor mutates captured values, or perhaps captures nothing at all, so it can
be called multiple times concurrently.</p>
<p><code>FnMut</code> is a subtype of <code>FnOnce</code>. <code>Fn</code> is a subtype of <code>FnMut</code> and <code>FnOnce</code>. I.e. you can use an
<code>FnMut</code> wherever an <code>FnOnce</code> is called for, and you can use an <code>Fn</code> wherever an <code>FnMut</code> or <code>FnOnce</code>
is called for.</p>
<p><code>move</code> closures only implement <code>FnOnce</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monomorphization"><a class="header" href="#monomorphization">Monomorphization</a></h1>
<p>Generic code is turned into non-generic code based on the call sites:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let integer = Some(5);
    let float = Some(5.0);
}
</code></pre></pre>
<p>behaves as if you wrote</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>This is a zero-cost abstraction: you get exactly the same result as if you had
hand-coded the data structures without the abstraction.</p>
<details>
<p><a href="https://rustc-dev-guide.rust-lang.org/backend/monomorph.html">Monomorphization</a></p>
<p>‚ÄúIn Rust, the compiler stamps out a different copy of the code of a generic function for each concrete type needed. For example, if I use a <code>Vec&lt;u64&gt;</code> and a <code>Vec&lt;String&gt;</code> in my code, then the generated binary will have two copies of the generated code for Vec: one for <code>Vec&lt;u64&gt;</code> and another for <code>Vec&lt;String&gt;</code>. The result is fast programs, but it comes at the cost of compile time (creating all those copies can take a while) and binary size (all those copies might take a lot of space).‚Äù This is different from Java, where the precise type is known at run-time and (almost) all variables are reference values (ie pointer to a heap allocated object). This has performance cost because of the dereference for each access.</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h1>
<p>We‚Äôve seen how a function can take arguments which implement a trait:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn print&lt;T: Display&gt;(x: T) {
    println!(&quot;Your value: {}&quot;, x);
}

fn main() {
    print(123);
    print(&quot;Hello&quot;);
}
</code></pre></pre>
<p>However, how can we store a collection of mixed types which implement <code>Display</code>?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let xs = vec![123, &quot;Hello&quot;];
}
</code></pre></pre>
<p>For this, we need <em>trait objects</em>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn main() {
    let xs: Vec&lt;Box&lt;dyn Display&gt;&gt; = vec![Box::new(123), Box::new(&quot;Hello&quot;)];
    for x in xs {
        println!(&quot;x: {x}&quot;);
    }
}
</code></pre></pre>
<p>Memory layout after allocating <code>xs</code>:</p>
<div style='width:100%; height:416px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="672" height="416"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="672" height="416"></rect><rect x="420" y="184" width="208" height="32" class="solid nofill" rx="0"></rect><text x="434" y="204" >&lt;str as Display&gt;::fmt</text><rect x="372" y="312" width="208" height="32" class="solid nofill" rx="0"></rect><text x="386" y="332" >&lt;i32 as Display&gt;::fmt</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >xs</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><circle cx="324" cy="88" r="3" class="nofill"></circle><circle cx="340" cy="88" r="3" class="nofill"></circle><circle cx="372" cy="88" r="3" class="nofill"></circle><circle cx="388" cy="88" r="3" class="nofill"></circle><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><text x="434" y="140" >H</text><text x="474" y="140" >e</text><text x="514" y="140" >l</text><text x="554" y="140" >l</text><text x="594" y="140" >o</text><text x="386" y="268" >7b</text><text x="426" y="268" >00</text><text x="466" y="268" >00</text><text x="506" y="268" >00</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><line x1="296" y1="392" x2="304" y2="392" class="solid"></line><line x1="312" y1="392" x2="320" y2="392" class="solid"></line><line x1="328" y1="392" x2="336" y2="392" class="solid"></line><line x1="344" y1="392" x2="352" y2="392" class="solid"></line><line x1="360" y1="392" x2="368" y2="392" class="solid"></line><line x1="376" y1="392" x2="384" y2="392" class="solid"></line><line x1="392" y1="392" x2="400" y2="392" class="solid"></line><line x1="408" y1="392" x2="416" y2="392" class="solid"></line><line x1="424" y1="392" x2="432" y2="392" class="solid"></line><line x1="440" y1="392" x2="448" y2="392" class="solid"></line><line x1="456" y1="392" x2="464" y2="392" class="solid"></line><line x1="472" y1="392" x2="480" y2="392" class="solid"></line><line x1="488" y1="392" x2="496" y2="392" class="solid"></line><line x1="504" y1="392" x2="512" y2="392" class="solid"></line><line x1="520" y1="392" x2="528" y2="392" class="solid"></line><line x1="536" y1="392" x2="544" y2="392" class="solid"></line><line x1="552" y1="392" x2="560" y2="392" class="solid"></line><line x1="568" y1="392" x2="576" y2="392" class="solid"></line><line x1="584" y1="392" x2="592" y2="392" class="solid"></line><line x1="600" y1="392" x2="608" y2="392" class="solid"></line><line x1="616" y1="392" x2="624" y2="392" class="solid"></line><line x1="632" y1="392" x2="640" y2="392" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="388" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,388 A 4,4 0,0,0 280,392" class="nofill"></path><line x1="280" y1="392" x2="288" y2="392" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="404" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="308" y1="104" x2="404" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="324" y1="92" x2="324" y2="324" class="solid"></line><path d="M 324,324 A 4,4 0,0,0 328,328" class="nofill"></path><line x1="328" y1="328" x2="360" y2="328" class="solid"></line><polygon points="360,324 368,328 360,332" class="filled"></polygon></g><g><line x1="340" y1="92" x2="340" y2="260" class="solid"></line><path d="M 340,260 A 4,4 0,0,0 344,264" class="nofill"></path><line x1="344" y1="264" x2="360" y2="264" class="solid"></line><polygon points="360,260 368,264 360,268" class="filled"></polygon></g><g><line x1="372" y1="92" x2="372" y2="196" class="solid"></line><path d="M 372,196 A 4,4 0,0,0 376,200" class="nofill"></path><line x1="376" y1="200" x2="408" y2="200" class="solid"></line><polygon points="408,196 416,200 408,204" class="filled"></polygon></g><g><line x1="388" y1="92" x2="388" y2="132" class="solid"></line><path d="M 388,132 A 4,4 0,0,0 392,136" class="nofill"></path><line x1="392" y1="136" x2="408" y2="136" class="solid"></line><polygon points="408,132 416,136 408,140" class="filled"></polygon></g><g><line x1="420" y1="120" x2="620" y2="120" class="solid"></line><line x1="420" y1="120" x2="420" y2="152" class="solid"></line><line x1="460" y1="120" x2="460" y2="152" class="solid"></line><line x1="500" y1="120" x2="500" y2="152" class="solid"></line><line x1="540" y1="120" x2="540" y2="152" class="solid"></line><line x1="580" y1="120" x2="580" y2="152" class="solid"></line><line x1="620" y1="120" x2="620" y2="152" class="solid"></line><line x1="420" y1="152" x2="620" y2="152" class="solid"></line></g><g><line x1="372" y1="248" x2="532" y2="248" class="solid"></line><line x1="372" y1="248" x2="372" y2="280" class="solid"></line><line x1="412" y1="248" x2="412" y2="280" class="solid"></line><line x1="452" y1="248" x2="452" y2="280" class="solid"></line><line x1="492" y1="248" x2="492" y2="280" class="solid"></line><line x1="532" y1="248" x2="532" y2="280" class="solid"></line><line x1="372" y1="280" x2="532" y2="280" class="solid"></line></g><g><line x1="648" y1="24" x2="656" y2="24" class="solid"></line><path d="M 656,24 A 4,4 0,0,1 660,28" class="nofill"></path><line x1="660" y1="28" x2="660" y2="388" class="broken"></line><line x1="648" y1="392" x2="656" y2="392" class="solid"></line><path d="M 660,388 A 4,4 0,0,1 656,392" class="nofill"></path></g></svg></div>
<p>Similarly, you need a trait object if you want to return different values
implementing a trait:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn numbers(n: i32) -&gt; Box&lt;dyn Iterator&lt;Item=i32&gt;&gt; {
    if n &gt; 0 {
        Box::new(0..n)
    } else {
        Box::new((n..0).rev())
    }
}

fn main() {
    println!(&quot;{:?}&quot;, numbers(-5).collect::&lt;Vec&lt;_&gt;&gt;());
    println!(&quot;{:?}&quot;, numbers(5).collect::&lt;Vec&lt;_&gt;&gt;());
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-5-exercises"><a class="header" href="#course-5-exercises">Course 5 Exercises</a></h1>
<p>We will design a classical GUI library traits and trait objects.</p>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-gui-library"><a class="header" href="#a-simple-gui-library">A Simple GUI Library</a></h1>
<p>Let us design a classical GUI library using our new knowledge of traits and
trait objects.</p>
<p>We will have a number of widgets in our library:</p>
<ul>
<li><code>Window</code>: has a <code>title</code> and contains other widgets.</li>
<li><code>Button</code>: has a <code>label</code> and a callback function which is invoked when the
button is pressed.</li>
<li><code>Label</code>: has a <code>label</code>.</li>
</ul>
<p>The widgets will implement a <code>Widget</code> trait, see below.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>, fill in the missing
<code>draw_into</code> methods so that you implement the <code>Widget</code> trait:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{}&quot;, &amp;buffer);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
    callback: Box&lt;dyn FnMut()&gt;,
}

impl Button {
    fn new(label: &amp;str, callback: Box&lt;dyn FnMut()&gt;) -&gt; Button {
        Button {
            label: Label::new(label),
            callback,
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }
}


impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;,
        Box::new(|| println!(&quot;You clicked the button!&quot;)),
    )));
    window.draw();
}
</code></pre></pre>
<p>The output of the above program can be something simple like this:</p>
<pre><code class="language-text">========
Rust GUI Demo 1.23
========

This is a small text GUI demo.

| Click me! |
</code></pre>
<p>If you want to draw aligned text, you can use the
<a href="https://doc.rust-lang.org/std/fmt/index.html#fillalignment">fill/alignment</a>
formatting operators. In particular, notice how you can pad with different
characters (here a <code>'/'</code>) and how you can control alignment:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let width = 10;
    println!(&quot;left aligned:  |{:/&lt;width$}|&quot;, &quot;foo&quot;);
    println!(&quot;centered:      |{:/^width$}|&quot;, &quot;foo&quot;);
    println!(&quot;right aligned: |{:/&gt;width$}|&quot;, &quot;foo&quot;);
}
</code></pre></pre>
<p>Using such alignment tricks, you can for example produce output like this:</p>
<pre><code class="language-text">+--------------------------------+
|       Rust GUI Demo 1.23       |
+================================+
| This is a small text GUI demo. |
| +-----------+                  |
| | Click me! |                  |
| +-----------+                  |
+--------------------------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In this 6th course, we will discover</p>
<ul>
<li>
<p>Error handling: panics, <code>Result</code>, and the try operator <code>?</code>.</p>
</li>
<li>
<p>Testing: unit tests, documentation tests, and integration tests.</p>
</li>
<li>
<p>Unsafe Rust: raw pointers, static variables, unsafe functions, and extern
functions.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Error handling in Rust is done using explicit control flow:</p>
<ul>
<li>Functions that can have errors list this in their return type,</li>
<li>There are no exceptions.</li>
</ul>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Doc on handling errors</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panics"><a class="header" href="#panics">Panics</a></h1>
<p>Rust will trigger a panic if a fatal error happens at runtime:</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}
</code></pre></pre>
<ul>
<li>Panics are for unrecoverable and unexpected errors.
<ul>
<li>Panics are symptoms of bugs in the program.</li>
</ul>
</li>
<li>Use non-panicking APIs (such as <code>Vec::get</code>) if crashing is not acceptable.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catching-the-stack-unwinding"><a class="header" href="#catching-the-stack-unwinding">Catching the Stack Unwinding</a></h1>
<p>By default, a panic will cause the stack to unwind. The unwinding can be caught:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused)]
fn main() {
use std::panic;

let result = panic::catch_unwind(|| {
    println!(&quot;hello!&quot;);
});
assert!(result.is_ok());

let result = panic::catch_unwind(|| {
    panic!(&quot;oh no!&quot;);
});
assert!(result.is_err());
}
</code></pre></pre>
<ul>
<li>This can be useful in servers which should keep running even if a single
request crashes.</li>
<li>This does not work if <code>panic = 'abort'</code> is set in your <code>Cargo.toml</code>.</li>
</ul>
<details>
<p>The <code>panic!</code> macro can be used to generate a panic and start unwinding its stack. While unwinding, the runtime will take care of freeing all the resources owned by the thread by calling the destructor of all its objects.</p>
<p><code>assert!</code> asserts that a boolean expression is <code>true</code> at runtime. This will invoke the <code>panic!</code> macro if the provided expression cannot be evaluated to true at runtime.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structured-error-handling-with-result"><a class="header" href="#structured-error-handling-with-result">Structured Error Handling with <code>Result</code></a></h1>
<p>We have already seen the <code>Result</code> enum. This is used pervasively when errors are
expected as part of normal operation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;
use std::io::Read;

fn main() {
    let file = File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            file.read_to_string(&amp;mut contents);
            println!(&quot;Dear diary: {contents}&quot;);
        },
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>As with <code>Option</code>, the successful value sits inside of <code>Result</code>, forcing the developer to
explicitly extract it. This encourages error checking. In the case where an error should never happen,
<code>unwrap()</code> or <code>expect()</code> can be called, and this is a signal of the developer intent too.</li>
<li><code>Result</code> documentation is a recommended read. Not during the course, but it is worth mentioning. 
It contains a lot of convenience methods and functions that help functional-style programming. </li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propagating-errors-with-"><a class="header" href="#propagating-errors-with-">Propagating Errors with <code>?</code></a></h1>
<p>The try-operator <code>?</code> is used to return errors to the caller. It lets you turn
the common</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}
</code></pre>
<p>into the much simpler</p>
<pre><code class="language-rust ignore">some_expression?
</code></pre>
<p>We can use this to simplify our error handing code:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs;
use std::io::{self, Read};

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>Key points:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty file, file with username.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types"><a class="header" href="#converting-error-types">Converting Error Types</a></h1>
<p>The effective expansion of <code>?</code> is a little more complicated than previously indicated:</p>
<pre><code class="language-rust ignore">expression?
</code></pre>
<p>works the same as</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}
</code></pre>
<p>The <code>From::from</code> call here means we attempt to convert the error type to the
type returned by the function:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types-1"><a class="header" href="#converting-error-types-1">Converting Error Types</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, File};
use std::io::{self, Read};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;IO error: {}&quot;, e),
            Self::EmptyUsername(filename) =&gt; write!(f, &quot;Found no username in {}&quot;, filename),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; ReadUsernameError {
        ReadUsernameError::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>Key points:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty file, file with username.</li>
</ul>
<p>It is good practice for all error types to implement <code>std::error::Error</code>, which requires <code>Debug</code> and
<code>Display</code>. It‚Äôs generally helpful for them to implement <code>Clone</code> and <code>Eq</code> too where possible, to make
life easier for tests and consumers of your library. In this case we can‚Äôt easily do so, because
<code>io::Error</code> doesn‚Äôt implement them.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-error-enums"><a class="header" href="#deriving-error-enums">Deriving Error Enums</a></h1>
<p>The <a href="https://docs.rs/thiserror/">thiserror</a> crate is a popular way to create an
error enum like we did on the previous page:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::{fs, io};
use std::io::Read;
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;Could not read: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p><code>thiserror</code>‚Äôs derive macro automatically implements <code>std::error::Error</code>, and optionally <code>Display</code>
(if the <code>#[error(...)]</code> attributes are provided) and <code>From</code> (if the <code>#[from]</code> attribute is added).
It also works for structs.</p>
<p>It doesn‚Äôt affect your public API, which makes it good for libraries.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-error-types"><a class="header" href="#dynamic-error-types">Dynamic Error Types</a></h1>
<p>Sometimes we want to allow any type of error to be returned without writing our own enum covering
all the different possibilities. <code>std::error::Error</code> makes this easy.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::fs::{self, File};
use std::io::Read;
use thiserror::Error;
use std::error::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(EmptyUsernameError(String::from(path)).into());
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p>This saves on code, but gives up the ability to cleanly handle different error cases differently in
the program. As such it‚Äôs generally not a good idea to use <code>Box&lt;dyn Error&gt;</code> in the public API of a
library, but it can be a good option in a program where you just want to display the error message
somewhere.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-context-to-errors"><a class="header" href="#adding-context-to-errors">Adding Context to Errors</a></h1>
<p>The widely used <a href="https://docs.rs/anyhow/">anyhow</a> crate can help you add
contextual information to your errors and allows you to have fewer
custom error types:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::{fs, io};
use std::io::Read;
use anyhow::{Context, Result, bail};

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .context(format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(&quot;Found no username in {path}&quot;);
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such it‚Äôs again generally not
a good choice for the public API of a library, but is widely used in applications.</li>
<li>Actual error type inside of it can be extracted for examination if necessary.</li>
<li>Functionality provided by <code>anyhow::Result&lt;T&gt;</code> may be familiar to Go developers, as it provides
similar usage patterns and ergonomics to <code>(T, error)</code> from Go.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Rust and Cargo come with a simple unit test framework:</p>
<ul>
<li>
<p>Unit tests are supported throughout your code.</p>
</li>
<li>
<p>Integration tests are supported via the <code>tests/</code> directory.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Mark unit tests with <code>#[test]</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[test]
fn test_empty() {
    assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
}

#[test]
fn test_single_word() {
    assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
}
</code></pre></pre>
<p>Use <code>cargo test</code> to find and run the unit tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-modules"><a class="header" href="#test-modules">Test Modules</a></h1>
<p>Unit tests are often put in a nested module (run tests on the
<a href="https://play.rust-lang.org/">Playground</a>):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn helper(a: &amp;str, b: &amp;str) -&gt; String {
    format!(&quot;{a} {b}&quot;)
}

pub fn main() {
    println!(&quot;{}&quot;, helper(&quot;Hello&quot;, &quot;World&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper() {
        assert_eq!(helper(&quot;foo&quot;, &quot;bar&quot;), &quot;foo bar&quot;);
    }
}
</code></pre></pre>
<ul>
<li>This lets you unit test private helpers.</li>
<li>The <code>#[cfg(test)]</code> attribute is only active when you run <code>cargo test</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h1>
<p>Rust has built-in support for documentation tests:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Code blocks in <code>///</code> comments are automatically seen as Rust code.</li>
<li>The code will be compiled and executed as part of <code>cargo test</code>.</li>
<li>Test the above code on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a>.</li>
</ul>
<details>
<pre><code>pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}

#[test]
fn test_single_word() {
    assert_eq!(shorten_string(&quot;Hello World&quot;,5), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(shorten_string(&quot;Hello World&quot;,20), &quot;Hello World&quot;);
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>If you want to test your library as a client, use an integration test.</p>
<p>Create a <code>.rs</code> file under <code>tests/</code>:</p>
<pre><code class="language-rust ignore">use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
</code></pre>
<p>These tests only have access to the public API of your crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h1>
<p>The Rust language has two parts:</p>
<ul>
<li><strong>Safe Rust:</strong> memory safe, no undefined behavior possible.</li>
<li><strong>Unsafe Rust:</strong> can trigger undefined behavior if preconditions are violated.</li>
</ul>
<p>We will be seeing mostly safe Rust in this course, but it‚Äôs important to know
what Unsafe Rust is.</p>
<p>Unsafe code is usually small and isolated, and its correctness should be carefully
documented. It is usually wrapped in a safe abstraction layer.</p>
<p>Unsafe Rust gives you access to five new capabilities:</p>
<ul>
<li>Dereference raw pointers.</li>
<li>Access or modify mutable static variables.</li>
<li>Access <code>union</code> fields.</li>
<li>Call <code>unsafe</code> functions, including <code>extern</code> functions.</li>
<li>Implement <code>unsafe</code> traits.</li>
</ul>
<p>We will briefly cover unsafe capabilities next. For full details, please see
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Chapter 19.1 in the Rust Book</a>
and the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>
<details>
<p>Unsafe Rust does not mean the code is incorrect. It means that developers have
turned off the compiler safety features and have to write correct code by
themselves. It means the compiler no longer enforces Rust‚Äôs memory-safety rules.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dereferencing-raw-pointers"><a class="header" href="#dereferencing-raw-pointers">Dereferencing Raw Pointers</a></h1>
<p>Creating pointers is safe, but dereferencing them requires <code>unsafe</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut num = 5;

    let r1 = &amp;mut num as *mut i32;
    let r2 = &amp;num as *const i32;

    // Safe because r1 and r2 were obtained from references and so are guaranteed to be non-null and
    // properly aligned, the objects underlying the references from which they were obtained are
    // live throughout the whole unsafe block, and they are not accessed either through the
    // references or concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = 10;
        println!(&quot;r2 is: {}&quot;, *r2);
    }
}
</code></pre></pre>
<details>
<p>It is good practice (and required by the Android Rust style guide) to write a comment for each
<code>unsafe</code> block explaining how the code inside it satisfies the safety requirements of the unsafe
operations it is doing.</p>
<p>In the case of pointer dereferences, this means that the pointers must be
<a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>, i.e.:</p>
<ul>
<li>The pointer must be non-null.</li>
<li>The pointer must be <em>dereferenceable</em> (within the bounds of a single allocated object).</li>
<li>The object must not have been deallocated.</li>
<li>There must not be concurrent accesses to the same location.</li>
<li>If the pointer was obtained by casting a reference, the underlying object must be live and no
reference may be used to access the memory.</li>
</ul>
<p>In most cases the pointer must also be properly aligned.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-static-variables"><a class="header" href="#mutable-static-variables">Mutable Static Variables</a></h1>
<p>It is safe to read an immutable static variable:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p>However, since data races can occur, it is unsafe to read and write mutable
static variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    unsafe { COUNTER += inc; }  // Potential data race!
}

fn main() {
    add_to_counter(42);

    unsafe { println!(&quot;COUNTER: {}&quot;, COUNTER); }  // Potential data race!
}
</code></pre></pre>
<details>
<p>Using a mutable static is generally a bad idea, but there are some cases where it might make sense
in low-level <code>no_std</code> code, such as implementing a heap allocator or working with some C APIs.</p>
<p><code>no_std</code> is used to prevent Rust from loading the standard library. This is used for bare metal development for example. <a href="https://docs.rust-embedded.org/book/intro/no-std.html">no_std in the Embedded Rust Book</a></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unions"><a class="header" href="#unions">Unions</a></h1>
<p>Unions are like enums, but you need to track the active field yourself:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b });  // Undefined behavior!
}
</code></pre></pre>
<details>
<p>Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally needed
for interacting with C library APIs.</p>
<p>If you just want to reinterpret bytes as a different type, you probably want
<a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> or a safe
wrapper such as the <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a> crate.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-unsafe-functions"><a class="header" href="#calling-unsafe-functions">Calling Unsafe Functions</a></h1>
<p>A function or method can be marked <code>unsafe</code> if it has extra preconditions you
must uphold to avoid undefined behaviour:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let emojis = &quot;üóª‚ààüåè&quot;;

    // Safe because the indices are in the correct order, within the bounds of
    // the string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;{}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;{}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;{}&quot;, emojis.get_unchecked(7..11));
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-unsafe-functions"><a class="header" href="#writing-unsafe-functions">Writing Unsafe Functions</a></h1>
<p>You can mark your own functions as <code>unsafe</code> if they require particular conditions to avoid undefined
behaviour.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // Safe because ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}
</code></pre></pre>
<details>
<p>We wouldn‚Äôt actually use pointers for this because it can be done safely with references.</p>
<p>Note that unsafe code is allowed within an unsafe function without an <code>unsafe</code> block. We can
prohibit this with <code>#[deny(unsafe_op_in_unsafe_fn)]</code>. Try adding it and see what happens.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-external-code"><a class="header" href="#calling-external-code">Calling External Code</a></h1>
<p>Functions from other languages might violate the guarantees of Rust. Calling
them is thus unsafe:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // Undefined behavior if abs misbehaves.
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<details>
<p>This is usually only a problem for extern functions which do things with pointers which might
violate Rust‚Äôs memory model, but in general any C function might have undefined behaviour under any
arbitrary circumstances.</p>
<p>The <code>&quot;C&quot;</code> in this example is the ABI;
<a href="https://doc.rust-lang.org/reference/items/external-blocks.html">other ABIs are available too</a>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-unsafe-traits"><a class="header" href="#implementing-unsafe-traits">Implementing Unsafe Traits</a></h1>
<p>Like with functions, you can mark a trait as <code>unsafe</code> if the implementation must guarantee
particular conditions to avoid undefined behaviour.</p>
<p>For example, the <code>zerocopy</code> crate has an unsafe trait that looks
<a href="https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html">something like this</a>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::size_of_val;
use std::slice;

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait AsBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))
        }
    }
}

// Safe because u32 has a defined representation and no padding.
unsafe impl AsBytes for u32 {}
</code></pre></pre>
<details>
<p>There should be a <code># Safety</code> section on the Rustdoc for the trait explaining the requirements for
the trait to be safely implemented.</p>
<p>The actual safety section for <code>AsBytes</code> is rather longer and more complicated.</p>
<p>The built-in <code>Send</code> and <code>Sync</code> traits are unsafe.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-6-exercises"><a class="header" href="#course-6-exercises">Course 6 Exercises</a></h1>
<p>Let us build a safe wrapper for reading directory content!</p>
<!-- <details>

After looking at the exercise, you can look at the [solution] provided.

[solution]: solutions-afternoon.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="safe-ffi-wrapper"><a class="header" href="#safe-ffi-wrapper">Safe FFI Wrapper</a></h1>
<p>Rust has great support for calling functions through a <em>foreign function
interface</em> (FFI). We will use this to build a safe wrapper for the <code>libc</code>
functions you would use from C to read the filenames of a directory.</p>
<p>You will want to consult the manual pages:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>You will also want to browse the <a href="https://doc.rust-lang.org/std/ffi/"><code>std::ffi</code></a> module, particular for <a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a>
and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a> types which are used to hold NUL-terminated strings coming from
C. The <a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon</a> also has a very useful chapter about FFI.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
functions and methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_long,
        pub d_off: c_ulong,
        pub d_reclen: c_ushort,
        pub d_type: c_char,
        pub d_name: [c_char; 256],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;
        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-course-7"><a class="header" href="#welcome-to-course-7">Welcome to course 7</a></h1>
<p>Today we will look at:</p>
<ul>
<li>Concurrency: threads, channels, shared state, <code>Send</code> and <code>Sync</code>.</li>
</ul>
<!-- * Android: building binaries and libraries, using AIDL, logging, and
  interoperability with C, C++, and Java.

> We will attempt to call Rust from one of your own projects today. So try to
> find a little corner of your code base where we can move some lines of code to
> Rust. The fewer dependencies and "exotic" types the better. Something that
> parses some raw bytes would be ideal. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency"><a class="header" href="#fearless-concurrency">Fearless Concurrency</a></h1>
<p>Rust has full support for concurrency using OS threads with mutexes and
channels.</p>
<p>The Rust type system plays an important role in making many concurrency bugs
compile time bugs. This is often referred to as <em>fearless concurrency</em> since you
can rely on the compiler to ensure correctness at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Rust threads work similarly to threads in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}
</code></pre></pre>
<ul>
<li>Threads are all daemon threads, the main thread does not wait for them.</li>
<li>Thread panics are independent of each other.
<ul>
<li>Panics can carry a payload, which can be unpacked with <code>downcast_ref</code>.</li>
</ul>
</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is
not waiting.</p>
</li>
<li>
<p>Use <code>let handle = thread::spawn(...)</code> and later <code>handle.join()</code> to wait for
the thread to finish.</p>
</li>
<li>
<p>Trigger a panic in the thread, notice how this doesn‚Äôt affect <code>main</code>.</p>
</li>
<li>
<p>Use the <code>Result</code> return value from <code>handle.join()</code> to get access to the panic
payload. This is a good time to talk about <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handler = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
    handler.join().unwrap();
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threads"><a class="header" href="#scoped-threads">Scoped Threads</a></h1>
<p>Normal threads cannot borrow from their environment:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}
</code></pre></pre>
<p>However, you can use a <a href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped thread</a> for this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}
</code></pre></pre>
<details>
<ul>
<li>The reason for that is that when the <code>thread::scope</code> function completes, all the threads are guaranteed to be joined, so they can return borrowed data.</li>
<li>Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by any number of threads.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Rust channels have two parts: a <code>Sender&lt;T&gt;</code> and a <code>Receiver&lt;T&gt;</code>. The two parts
are connected via the channel, but you only see the end-points.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}
</code></pre></pre>
<details>
<ul>
<li><code>mpsc</code> stands for Multi-Producer, Single-Consumer. <code>Sender</code> and <code>SyncSender</code> implement <code>Clone</code> (so
you can make multiple producers) but <code>Receiver</code> does not.</li>
<li><code>send()</code> and <code>recv()</code> return <code>Result</code>. If they return <code>Err</code>, it means the counterpart <code>Sender</code> or
<code>Receiver</code> is dropped and the channel is closed.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unbounded-channels"><a class="header" href="#unbounded-channels">Unbounded Channels</a></h1>
<p>You get an unbounded and asynchronous channel with <code>mpsc::channel()</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {}&quot;, msg);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded-channels"><a class="header" href="#bounded-channels">Bounded Channels</a></h1>
<p>Bounded and synchronous channels make <code>send</code> block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {}&quot;, msg);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-state"><a class="header" href="#shared-state">Shared State</a></h1>
<p>Rust uses the type system to enforce synchronization of shared data. This is
primarily done via two types:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>, atomic reference counted <code>T</code>: handles sharing between threads and
takes care to deallocate <code>T</code> when the last reference is dropped,</li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a>: ensures mutually exclusive access to the <code>T</code> value.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> allows shared read-only access via its <code>clone</code> method:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::sync::Arc;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 1..5 {
        let v = v.clone();
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Arc</code> stands for ‚ÄúAtomic Reference Counted‚Äù, a thread safe version of <code>Rc</code> that uses atomic
operations.</p>
<p>‚ÄúThe type Arc<T> provides shared ownership of a value of type T, allocated in the heap. Invoking clone on Arc produces a new Arc instance, which points to the same allocation on the heap as the source Arc, while increasing a reference count. When the last Arc pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as ‚Äúinner value‚Äù) is also dropped.‚Äù from <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">1</a>.</p>
<p>Also see <a href="https://medium.com/@DylanKerler1/how-arc-works-in-rust-b06192acd0a6">How arc works in rust</a></p>
</li>
<li>
<p><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> iff <code>T</code>
implements them both.</p>
</li>
<li>
<p><code>Arc::clone()</code> has the cost of atomic operations that get executed, but after that the use of the
<code>T</code> is free.</p>
</li>
<li>
<p>Beware of reference cycles, <code>Arc</code> does not use a garbage collector to detect them.</p>
<ul>
<li><code>std::sync::Weak</code> can help.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutex"><a class="header" href="#mutex"><code>Mutex</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> ensures mutual exclusion <em>and</em> allows mutable access to <code>T</code>
behind a read-only interface:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::Mutex;

fn main() {
    let v: Mutex&lt;Vec&lt;i32&gt;&gt; = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let v: &amp;Mutex&lt;Vec&lt;i32&gt;&gt; = &amp;v;
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}
</code></pre></pre>
<p>Notice how we have a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> blanket
implementation.</p>
<details>
<ul>
<li><code>Mutex</code> in Rust looks like a collection with just one element - the protected data.
<ul>
<li>It is not possible to forget to acquire the mutex before accessing the protected data.</li>
</ul>
</li>
<li>You can get an <code>&amp;mut T</code> from an <code>&amp;Mutex&lt;T&gt;</code> by taking the lock. The <code>MutexGuard</code> ensures that the
<code>&amp;mut T</code> doesn‚Äôt outlive the lock being held.</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> iff <code>T</code> implements <code>Send</code>.</li>
<li>A read-write lock counterpart - <code>RwLock</code>.</li>
<li>Why does <code>lock()</code> return a <code>Result</code>? 
<ul>
<li>If the thread that held the <code>Mutex</code> panicked, the <code>Mutex</code> becomes ‚Äúpoisoned‚Äù. The error signals that
the data it protected might be in an inconsistent state. Calling <code>lock()</code> on a poisoned mutex
fails with a <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>. You can call <code>into_inner()</code> on the error to recover the data
regardless.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1"><a class="header" href="#example-1">Example</a></h1>
<p>Let us see <code>Arc</code> and <code>Mutex</code> in action:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let mut v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<p>Possible solution:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = v.clone();
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    {
        let v = v.lock().unwrap();
        println!(&quot;v: {v:?}&quot;);
    }
}
</code></pre></pre>
<p>Notable parts:</p>
<ul>
<li><code>v</code> is wrapped in both <code>Arc</code> and <code>Mutex</code>, because their concerns are orthogonal.
<ul>
<li>Wrapping a <code>Mutex</code> in an <code>Arc</code> is a common pattern to share mutable state between threads.</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> needs to be cloned as <code>v2</code> before it can be moved into another thread. Note <code>move</code> was added to the lambda signature.</li>
<li>Blocks are introduced to narrow the scope of the <code>LockGuard</code> as much as possible.</li>
<li>We still need to acquire the <code>Mutex</code> to print our <code>Vec</code>.</li>
</ul>
<p>Below is code to slowdown the main thread to invert the pushes into the vector.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = v.clone();
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    thread::sleep(Duration::from_millis(10));

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    {
        let v = v.lock().unwrap();
        println!(&quot;v: {v:?}&quot;);
    }
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync"><code>Send</code> and <code>Sync</code></a></h1>
<p>How does Rust know to forbid shared access across thread? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>: a type <code>T</code> is <code>Send</code> if it is safe to move a <code>T</code> across a thread
boundary.</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>: a type <code>T</code> is <code>Sync</code> if it is safe to move a <code>&amp;T</code> across a thread
boundary.</li>
</ul>
<p><code>Send</code> and <code>Sync</code> are <a href="concurrency/../unsafe/unsafe-traits.html">unsafe traits</a>. The compiler will automatically derive them for your types
as long as they only contain <code>Send</code> and <code>Sync</code> types. You can also implement them manually when you
know it is valid.</p>
<details>
<ul>
<li>One can think of these traits as markers that the type has certain thread-safety properties.</li>
<li>They can be used in the generic constraints as normal traits.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send"><a class="header" href="#send"><code>Send</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> if it is safe to move a <code>T</code> value to another thread.</p>
</blockquote>
<p>The effect of moving ownership to another thread is that <em>destructors</em> will run
in that thread. So the question is when you can allocate a value in one thread
and deallocate it in another.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> if it is safe to access a <code>T</code> value from multiple
threads at the same time.</p>
</blockquote>
<p>More precisely, the definition is:</p>
<blockquote>
<p><code>T</code> is <code>Sync</code> if and only if <code>&amp;T</code> is <code>Send</code></p>
</blockquote>
<details>
<p>This statement is essentially a shorthand way of saying that if a type is thread-safe for shared use, it is also thread-safe to pass references of it across threads.</p>
<p>This is because if a type is Sync it means that it can be shared across multiple threads without the risk of data races or other synchronization issues, so it is safe to move it to another thread. A reference to the type is also safe to move to another thread, because the data it references can be accessed from any thread safely.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<h2 id="send--sync"><a class="header" href="#send--sync"><code>Send + Sync</code></a></h2>
<p>Most types you come across are <code>Send + Sync</code>:</p>
<ul>
<li><code>i8</code>, <code>f32</code>, <code>bool</code>, <code>char</code>, <code>&amp;str</code>, ‚Ä¶</li>
<li><code>(T1, T2)</code>, <code>[T; N]</code>, <code>&amp;[T]</code>, <code>struct { x: T }</code>, ‚Ä¶</li>
<li><code>String</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>, ‚Ä¶</li>
<li><code>Arc&lt;T&gt;</code>: Explicitly thread-safe via atomic reference count.</li>
<li><code>Mutex&lt;T&gt;</code>: Explicitly thread-safe via internal locking.</li>
<li><code>AtomicBool</code>, <code>AtomicU8</code>, ‚Ä¶: Uses special atomic instructions.</li>
</ul>
<p>The generic types are typically <code>Send + Sync</code> when the type parameters are
<code>Send + Sync</code>.</p>
<h2 id="send--sync-1"><a class="header" href="#send--sync-1"><code>Send + !Sync</code></a></h2>
<p>These types can be moved to other threads, but they‚Äôre not thread-safe.
Typically because of interior mutability:</p>
<ul>
<li><code>mpsc::Sender&lt;T&gt;</code></li>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2 id="send--sync-2"><a class="header" href="#send--sync-2"><code>!Send + Sync</code></a></h2>
<p>These types are thread-safe, but they cannot be moved to another thread:</p>
<ul>
<li><code>MutexGuard&lt;T&gt;</code>: Uses OS level primitives which must be deallocated on the
thread which created them.</li>
</ul>
<h2 id="send--sync-3"><a class="header" href="#send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>These types are not thread-safe and cannot be moved to other threads:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>: each <code>Rc&lt;T&gt;</code> has a reference to an <code>RcBox&lt;T&gt;</code>, which contains a
non-atomic reference count.</li>
<li><code>*const T</code>, <code>*mut T</code>: Rust assumes raw pointers may have special
concurrency considerations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>Let us practice our new concurrency skills with</p>
<ul>
<li>
<p>Dining philosophers: a classic problem in concurrency.</p>
</li>
<li>
<p>Multi-threaded link checker: a larger project where you‚Äôll use Cargo to
download dependencies and then check links in parallel.</p>
</li>
</ul>
<!-- <details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details> -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="dining-philosophers"><a class="header" href="#dining-philosophers">Dining Philosophers</a></h1>
<p>The dining philosophers problem is a classic problem in concurrency:</p>
<blockquote>
<p>Five philosophers dine together at the same table. Each philosopher has their
own place at the table. There is a fork between each plate. The dish served is
a kind of spaghetti which has to be eaten with two forks. Each philosopher can
only alternately think and eat. Moreover, a philosopher can only eat their
spaghetti when they have both a left and right fork. Thus two forks will only
be available when their two nearest neighbors are thinking, not eating. After
an individual philosopher finishes eating, they will put down both forks.</p>
</blockquote>
<p>You will need a local <a href="exercises/course-7/../../cargo/running-locally.html">Cargo installation</a> for
this exercise. Copy the code below to <code>src/main.rs</code> file, fill out the blanks,
and test that <code>cargo run</code> does not deadlock:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::mpsc;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-threaded-link-checker"><a class="header" href="#multi-threaded-link-checker">Multi-threaded Link Checker</a></h1>
<p>Let us use our new knowledge to create a multi-threaded link checker. It should
start at a webpage and check that links on the page are valid. It should
recursively check other pages on the same domain and keep doing this until all
pages have been validated.</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. Create a new
Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">$ cargo new link-checker
$ cd link-checker
$ cargo add --features blocking,rustls-tls reqwest
</code></pre>
<blockquote>
<p>If <code>cargo add</code> fails with <code>error: no such subcommand</code>, then please edit the
<code>Cargo.toml</code> file by hand. Add the dependencies listed below.</p>
</blockquote>
<p>You will also need a way to find links. We can use <a href="https://docs.rs/scraper/"><code>scraper</code></a> for that:</p>
<pre><code class="language-shell">$ cargo add scraper
</code></pre>
<p>Finally, we‚Äôll need some way of handling errors. We use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> for
that:</p>
<pre><code class="language-shell">$ cargo add thiserror
</code></pre>
<p>The <code>cargo add</code> calls will update the <code>Cargo.toml</code> file to look like this:</p>
<pre><code class="language-toml">[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>You can now download the start page. Try with a small site such as
<code>https://www.google.org/</code>.</p>
<p>Your <code>src/main.rs</code> file should look something like this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use reqwest::blocking::{get, Response};
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
}

fn extract_links(response: Response) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    let base_url = response.url().to_owned();
    let document = response.text()?;
    let html = Html::parse_document(&amp;document);
    let selector = Selector::parse(&quot;a&quot;).unwrap();

    let mut valid_urls = Vec::new();
    for element in html.select(&amp;selector) {
        if let Some(href) = element.value().attr(&quot;href&quot;) {
            match base_url.join(href) {
                Ok(url) =&gt; valid_urls.push(url),
                Err(err) =&gt; {
                    println!(&quot;On {base_url}: could not parse {href:?}: {err} (ignored)&quot;,);
                }
            }
        }
    }

    Ok(valid_urls)
}

fn main() {
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let response = get(start_url).unwrap();
    match extract_links(response) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}
</code></pre></pre>
<p>Run the code in <code>src/main.rs</code> with</p>
<pre><code class="language-shell">$ cargo run
</code></pre>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<ul>
<li>Use threads to check the links in parallel: send the URLs to be checked to a
channel and let a few threads check the URLs in parallel.</li>
<li>Extend this to recursively extract links from all pages on the
<code>www.google.org</code> domain. Put an upper limit of 100 pages or so so that you
don‚Äôt end up being blocked by the site.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ga4.js"></script>
        <script src="speaker-notes.js"></script>
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
